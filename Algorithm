// 算法在计算中的作用
// 1.1 算法Algorithm
//   任何良定义的计算过程，将某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法在这个过程中就是一系列计算步骤的序列。
//   对一个问题的阐述，表明期望的输入/输出关系，算法描述了一个特定过程来实现这种关系。
//   正确的算法：输入实例算法以正确的输出停机。
//   不正确的算法在错误率可控时可能是可用的。
//   算法问题共有的特征：1 存在许多候选解，找尽可能的最优解。  2 存在实际应用。

// 1.1.1  以排序问题举例：
//     输入：n个数的序列
//     输出：输入序列的一个排列，满足一定关系
//     给定输入序列，称为排序问题的一个实例。   问题实例由计算该问题必须的（满足问题中的各种约束）输入组成。
//   排序问题在应用中选择算法的影响因素：将被排序的项数、这些项已被排序的程度、项值的限制、计算机体系结构、存储设备种类。

// 1.1.2 数据结构：一种存储和组织数据的方式，旨在便于访问和修改。

// 1.1.3 技术：无法用已有算法来解决问题时，能够自行设计算法、证明正确性、计算其效率。

// 1.1.4 难题
//   对于有效算法，用产生结果需要的时间来衡量其效率。
//   对于未知有效算法的问题，称之为难题。
//       如：NP完全问题（Non-deterministic Polynomial Problem/多项式复杂程度的非确定性问题）
//       1 现状：目前仍未找到对NP完全问题的有效算法
//       2 其性质：如果任一Np完全问题存在有效算法，那么所有NP完全问题都存在有效算法。
//       3 意义：有几个NP完全问题类似存在有效算法的问题，但不完全等同。可以用对问题陈述的小变动来极大改变已有算法的效率。
//       所以，如果一个问题NP完全，可以有有效算法去解决，但不一定是最佳算法，这种算法被称为“近似算法”。

// 1.1.5 并行性
//   单线程：一个计算核心处理问题，一步一步顺序往下运行。（随着功率提高，存在物理限制，不能无限提高性能）
//   多线程（并行）：用多个计算核心，分解问题，每个核心负责部分运算。（可以通过增加核心量来提高计算效率）
//   因此为了从多核计算机获取最佳性能，设计算法时要考虑并行性。


// 1.2.2 算法与其他技术
//   其他对系统性能重要的技术：
//     先进的计算机体系结构与制造技术
//     易于使用、直观的图形用户界面
//     面向对象的系统
//     集成的万维网技术
//     有线与无线的快速组网



// 算法基础
// 介绍一个贯彻始终的框架，后续的算法设计与分析都基于这个框架，就像骨头上长出肌肉、血管乃至皮肤。
// 以排序问题的插入排序算法为例，引入伪代码说明算法执行步骤、功能，分析其运行时间。
// 引入分治法开发归并排序算法，分析其运行时间。

// 2.1 插入排序
//   选出一个数，从左向右（其实就是按一个顺序）依次比较，然后放入合适的位置。
// 例
//int main()
//{
//	int arr[5];
//	int i, j, t;
//	printf("输入5个元素：");
//	for (i = 0; i < 5; i++)
//		scanf_s("%d", &arr[i]);
//	for (j = 1; j < 5; j++)       // 指出正在被插入的当前数。
//	{
//		t = arr[j];
//		i = j - 1;
//		while (i >= 0 && arr[i] > t) //循环不变式
//		{
//			arr[i + 1] = arr[i];
//			i = i - 1;
//		}
//		arr[i + 1] = t;
//	}
//	for (i = 0; i < 5; i++)
//		printf("%d ", arr[i]);
//	return 0;
//}
// 循环不变式三条性质
//     1 初始化：循环第一次迭代之前为真。（循环起码能运行一次）
//     2 保持：如果循环某次迭代为真，那下次迭代之前仍为真。（保证未满足终止条件时，循环能正常继续下去）
//     3 终止：循环终止时，证明算法是正确的。（类似for，while循环的终止条件）
// 伪代码中的一些约定：
//       1 缩进代表块结构。
//       2 退出循环后，计数器保持当前值。
//       3 符号//后内容表示注释。
//       4 多重赋值表达式，r如i=j=e,将e的值赋给i和j。
//       5 若无特殊说明，变量均为局部变量。
//       6 数组元素通过数组名[下标]来访问。
//       7 复合数据通常被组织成对象，对象又由属性组成。对象名.属性名，可以逐级向下访问。
//         把表示一个数组或对象的变量看做是其指针。y=x后，xy指向相同的对象。
//         属性记号还可串联。如f指向g，记作f.g，又x.f.g。如果y=x.f ,根据上一条有x.f.g = y.g
//         空指针可以记作NIL
//       8 按值把参数传递给过程，当对象被传递时，指向表示对象数据的指针被复制而其属性没有。

// 2.2 分析算法
//   分析算法的结果意味着预测算法需要的资源。通过分析求解某个问题的候选算法，从中选出最有效的。
//   分析前要使用一个实现技术的模型（一台假想电脑）。本书中假定为一种通用的单处理器计算模型（随机访问机）
//   RAM模型包含真实计算机的常见指令：算术指令、数据移动指令、控制指令。每条指令所需时间均为常量。
//          数据类型：整数型、浮点型。 对每个数据字节假定一个范围以符合使用需要、实际情况。
//          分析过程需要使用到的数学工具可能包括：组合学、概率论、代数技巧，识别一个公式中最具意义的项。
//          通常只选一种机器模型来分析某个给定的算法。

// 2.2.1 插入排序算法的分析（asymptotic analysis渐进分析）
//   2.2.1.1 插入排序过程需要的时间依赖输入规模。 一般来说，算法需要时间随输入规模同步增长，所以将一个程序的运行时间描述为输入规模的函数。
//       输入规模：依赖研究的问题。对不同问题，输入规模的量度不同（单位不同）。
//       运行时间：执行的基本操作数或步数
//   分析过程中，由繁到简地改进运行时间表达式，并用简单记号表示语句代价Ci（忽略具体的实际代价），更关注增长率。
//               假定注释是不可执行语句，不需要运行时间。
//   2.2.1.2 现分析伪代码如下：
//   for j=2 to A.length           c1  n
//       key = A[j]                c2  n-1
//       // insert A[j] into sort   0  n-1
//       i=j-1                     c4  n-1
//       while i>0 and A[i]>key    c5  tj(for j=2 to n求和)
//             A[i+1] = A[i]       c6  tj-1(for j=2 to n求和)
//             i = i -1            c7  tj-1(for j=2 to n求和)
//       A[i+1] = key              c8  n-1
//   算法运行时间=代价 x 次数 的总和
//   T(n) = c1n + c2(n-1) + c4(n-1) + c5(求和tj) + c6(求和tj-1) + c7(求和tj-1) + c8(n-1)
//       最佳情况 T(n) = (c1+c2+c4+c5+c8)n - (c2+c4+c5+c8) = an - b
//       最坏情况 T(n) = (c5/2+c6/2+c7/2)nn + (c1+c2+c4+c5/2-c6/2-c7/2+c8)n - (c2+c4+c5+c8) = ann + bn + c
//   注：通常运行时间对给定输入是固定的，但是也有一些随机化算法（对固定输入，其行为可能变化导致运行时间不定）

// 2.2.2 最坏情况和平均情况的分析
//     往往只考虑求最坏情况的运行时间，即对于输入规模n，算法最长运行时间。
//         最坏情况运行时间给出任何输入的运行时间上界，能确保该算法绝不会超出这个运行时间。
//         对于某些算法，最坏情况经常出现。
//         平均情况往往和最坏情况一样差。
//         随机化算法中，假定给定规模的所有输入具有相同的可能性，以允许进行概率分析并产生某个期望的运行时间。
// 注：期望是一种均值，是试验中每次可能结果的概率 x 结果的总和，用于反应随机变量平均取值大小。

// 2.2.3 增长量级
//   使用简化抽象以化简分析。
//       Ci表示代价以忽略实际代价。常量a,b,c忽略Ci进一步简化
//       关注增长率，只考虑最重要的项，如最高次项。
//       当忽略低价项及最重要项的常系数时，使用asymptotic notation（theta），记为o(最重要项因子)


// 2.3 设计算法
//   插入排序使用了增量方法（排序好子列后，将后面的元素插入子列）
//   分治法，其最坏运行时间比插入排序要少得多。
// 2.3.1 分治法
//   在算法结构上是递归的：为了解决一个给定问题，一次或多次递归调用自身来解决相关的子问题。
//   思想：原问题分解为规模较小且类似的子问题，递归求解子问题，合并子问题的解来求出原问题的解。
//   步骤：分解，解决，合并。  当待排序列长度为1时，递归开始回升。
//   2.3.1.1 
//     MERGE(A,p,q,r) 合并函数，用于合并子数列A[p...q]和A[q+1...r],结果为A[p...r]
//     过程MERGE需要o(n)的时间 n=r-p+1（待合并元素总数），每次比较两个数组的当前元素，较小的放到输出数组中，放一次比一次，直到n个元素全放入输出数组。
//     如果当一个数组已经全部放入输出数组，则另一个数组剩余元素没有必要继续比较，可直接顺次放入输出数组。所以在数组底部放特殊值，当比较时出现该值可直接跳过比较。
//     伪代码如下：
//     MERGE(A,p,q,r)
//       n1=q-p+1
//       n2=r-q
//       //let L[1...n1+1]  and R[1...n2+1] be new arrays
//       for i=1 to n1
//           L[i] = A[p+i-1]
//       for j=1 to n2
//           R[j] = A[q+j]
//       L[n1+1] = infinitas
//       R[n2+1] = infinitas
//       i = 1
//       j = 1
//       for k=p to r
//           if L[i] <= R[j]
//              A[k] = L[i]
//              i = i + 1
//           else A[k] = R[j]
//                j = j + 1
//     MERGE-SORT (A,p,r)
//       if p<r
//          q=[(p+r)/2] (取整)
//           MERGE-SORT (A,q,r)
//           MERGE-SORT (A,q+1,r)
//           MERGE (A,p,q,r)
//     C语言封装成函数如下： //(有问题)
//void Merge(char arr[],int p,int q,int r)
//{
//	int i, j, k, n1, n2;
//	n1 = q - p;
//	n2 = r - q;
//	char L[5], R[5];
//	for (i = 0; i < n1; i++)
//		L[i] = arr[p + i];
//	for (j = 0; j < n2; j++)
//		R[j] = arr[q + j];
//	L[i + 1] = 'N';
//	R[i + 1] = 'N';
//	i = 0;
//	j = 0;
//	for (k = p; k < r; k++)
//	{
//		if (L[i] <= R[j])
//		{
//			arr[k] = L[i];
//			i++;
//		}
//		else
//		{
//			arr[k] = R[j];
//			j++;
//		}
//	}
//}
//void Merge_sort(char arr[], int p, int r)
//{
//	int q = 0;
//	if (p < r)
//	{
//		q = (p + r) / 2;
//		Merge_sort(arr, p, q);      // 左列排序
//		Merge_sort(arr, q + 1, r);  // 右列排序
//		Merge(arr, p, q, r);        // 合并左右列
//	}
//}
//int main()
//{
//	int i;
//	char arr[6] = { '2','6','4','5','9','1' };
//	int p = 0;
//	int r = sizeof(arr);
//	/*printf("%d", r);*/
//	Merge_sort(arr, p, r);
//	for (i = 0; i < r; i++)
//		printf("%c ", arr[i]);
//	return 0;
//}

// test
// 2.3-2 重写MERGE，不用哨兵。
//   MERGE(A,p,q,r)
//   n1=q-p+1
//   n2=r-q
//   for i=1 to n1
//       L[i]=A[p+i-1]
//   for j=1 t0 n2
//       R[j]=A[q+j]
//   i=1
//   j=1
//   while i<=q and j<=r
//        for k=p to r
//          if L[i]<=R[j]
//             A[k]=L[i]
//             i=i+1
//          else A[k]=R[j]
//               j=j+1
//   while k<=r  
//        if i == q+1
//           A[k]=R[j]
//           k=k+1
//           j=j+1
//         else
//           A[k]=L[i]
//           k=k+1
//           j=j+1

// 2.3.4 插入排序：为排序A[1...n],递归排序A[1...n-1],然后插入A[n]，求最坏运行时间递归式
//   1 分解：当数组只剩一个元素时，耗时为常量，记作o(1)
//   2 解决：递归求解n-1个元素，需要时间T(n-1)
//   3 合并：一个具有n-1个元素的数组，插入第n个元素需要时间cn
//   递归式 T(n) = o(1)         n=1
//               = T(n-1) + cn  n>1

// 2.3.5 二分法查找最坏运行时间
//   BINARY_SEARCH(A,x)
//     low=1
//     high=A.length
//     while low<=high
//       mid=(low+high)/2
//       if A[mid] == x
//          return mid
//       elseif A[mid]<x
//          low=mid+1
//       else
//          high=mid-1
//   T(n+1)=T(n/2)+c  最坏运行时间o(lgn)

// 2.3.7 给定n个整数的集合S和另一个整数x，确定S中是否存在两个和刚好为x的元素，其运行时间为o(nlgn)
//   SUM_FIND(S,x)
//     MERGE_SORT(S,1,S.length) // 先将S从小到大归并排序 o(nlgn)
//     for i=1 to S.length      // 再二分法查找是否存在两个数和为x。 需要时间： n x o(lgn) = o(nlgn)
//         if BINARY_SEARCH(S,x-S[i]) != nil // 找到了
//            return ture
//     return false                          // 没找到
//     总运行时间为o(nlgn)

// 2.1 在归并排序中对小数组采用插入排序
//   1 插入排序：排序n/k个长度为k的子表。排序一个需要T(k)=akk+bk+c,n/k个T=n/k(akk+bk+c)=ank+bn+cn/k=o(nk)
//   2 递归式 T(a)= 0          a=1
//              = T(a/2)+ak  a=2
//     归纳得 T(a)=aklga
//     T(n/k)=nlg(n/k)   so  o(nlg(n/k))
//   3 o(nk+nlg(n/k))<=o(nlgn)
//     so k<=lg(n/k)   k max 满足k2k次幂<n
//   4 当递归的子问题耗时大于直接插入排序时对应的k即为所求

// 2.2 冒泡排序正确性
//   1 还需证明A'中的所有元素就是A中各个元素
//   2 证明j循环的循环不变式
//     初始化：第一轮迭代开始前，只有j=A[length]一个元素，显然已排序，所以第一轮迭代之前已成立
//     保持：  迭代之前，假设A[j]...A[length]是已排序的，待排序元素A[j-1]依次与A[j]...A[length]比较，
//             如果A[j-1] > A[j],则交换位置，此时整个数列已排好序。
//             即j成立情况下，j-1也成立，证明其迭代过程中保持成立。
//     终止：  当i=A.length-1时，j=A.length,A'[1...n]个元素都已排好序。
//   3 证明i,j循环不变式
//     初始化：第一次循环开始时，A[1...i-1]为空数组，循环不变式成立。
//     保持：  A[1...i-1]满足循环不变式条件，j循环保证A[i]为A[i...n]中最小的元素。
//             迭代之前，A[1...i-1]内是已升序排序的数组，且A[i]大于A[1...i-1]中每个元素
//             即A[1...i-1]成立条件下，A[1...i]也成立,证明其迭代过程中保持成立。
//     终止：  i=n,A[1...n-1]满足循环不变式，由于A[1...n-1]由数组中最小的数组成，则A[n]必大于[1...n-1]所有数，则A[1...n]已排好序。
//   4 冒泡排序最坏运行时间o(nn),且无论是否已排好序。每次都执行判断，循环总次数不变,实际运行时间恒等于o(nn).
//     插入排序最坏运行时间o(nn),一旦找到插入位置循环结束，实际运行时间<=o(nn)
//     总体而言，插入排序性能更佳

// 2.3 霍纳Horner规则正确性
//   给定系数ai(i=1...n)和x的值
//   y=0
//   for i=n downto 0
//       y=ai + xy
//   实现了求值多项式 P(x) = 求和ak(x的k次幂) = a0 + x(a2+...+x(an-1+xan)...))
//   1 o(n)
//   2 嵌套循环城际结果累加 o(nn),比霍纳规则慢
//   3 证明循环不变式
//     初始化：i=n,y=0,循环不变式成立。
//     保持：  迭代开始时，y=求和(k=0,n-i-1)a(k+i+1)(x的k次幂)
//             循环后y = ai+x求和(k=0,n-i-1)a(k+i+1) = ai(x的0次幂)+求和(k=1,n-i)a(k+i)(x的k次幂)
//             y = a(k+i)(x的0次幂) + 求和(k=1,n-i)a(k+i)(x的k次幂) = 求和(k=0,n-i)a(k+i)(x的k次幂)迭代过程中保持成立。
//     终止：i=-1 ,y=求和(k=0,n)ak(x的k次幂)

// 2.4 逆序对 数组元素大小顺序与下标顺序相反
//   1 2，3，8，6，1的五个逆序对 ： (3,4),(3,5),(4,5),(1,5),(2,5)
//   2 {n...2,1}具有最多逆序对，有(n-1+1)(n-1)/2
//   3 INSERTION_SORT(A):
//        c=0
//        for j=2 to A.length
//            key=A[j]
//            i=j-1
//            while i>0 and A[i]>key
//                  A[i+1]=A[i]
//                  i=i-1
//                  c=c+1
//             A[i-1]=key
//    Prove：
//          1 初始化：第一次循环开始前，c=0，A[1]只有一个元素，不存在逆序对，不变式成立。
//          2 保持：  c为当前A[1...j-1]的逆序对个数。
//                    本次循环时，在A[1...j-1]中找比A[j]大的元素，直至退出子循环。
//                    循环结束A[1...j-1]都比A[j]小，A[j+1...n]都比A[j]大。此时c为A[j]与A[1...j-1]的逆序对个数，不变成成立。
//          3 终止：   j=A.length+1，c为A[1...n]的逆序对个数。
//    4 
//int Merge(int arr[], int p, int q, int r)
//{
//	int c = 0, k = 0, i, j;
//	int n1 = q - p + 1;
//	int n2 = r - q;
//	int* L = (int*)malloc((n1+1) * sizeof(int));
//	int* R = (int*)malloc((n2+1) * sizeof(int));
//	for (i = 0; i < n1; i++)
//		*(L + i) = arr[p + i];
//	for (j = 0; j < n2; j++)
//		*(R + j) = arr[q + 1 + j];
//	*(L + i) = 100;
//	*(R + j) = 100;
//	i = 0;
//	j = 0;
//	for (k = p; k <= r; k++)
//	{
//		if (*(L + i) <= *(R + j))
//		{
//			arr[k] = *(L + i);
//			i++;
//		}
//		else
//		{
//			arr[k] = *(R + j);
//			j++;
//			c++;
//		}
//	}
//	//while( i<=q && j<=r)
//	//{
//	//	for (k = p; k <= r; k++)
//	//	{
//	//		if (*(L + i) <= *(R + j))
//	//		{
//	//			arr[k] = *(L + i);
//	//			i++;
//	//		}
//	//		else
//	//		{
//	//			arr[k] = *(R + j);
//	//			j++;
//	//			c++;
//	//		}
//	//	}
//	//}
//	//while (k <= r)
//	//{
//	//	if (i == q + 1)
//	//	{
//	//		arr[k] = *(R + j);
//	//		k++;
//	//		j++;
//	//	}	
//	//	else
//	//	{
//	//		arr[k] = *(L + i);
//	//		k++;
//	//		j++;
//	//	}
//	//}
//	free(L);
//	free(R);
//	return c;
//}
//int Merge_sortC(int arr[], int p, int r)
//{
//	int c = 0;
//	if (p < r)
//	{
//		int q = (p + r) / 2;
//		return Merge_sortC(arr, p, q) + Merge_sortC(arr, q + 1, r) + Merge(arr, p, q, r);
//	}
//	else
//		return 0;
//}

//int Merge_sort(int a[], int p, int q, int r)
//{
//	int t[5];
//	int c = 0;
//	int i = p;
//	int j = q + 1;
//	for (int k = p; k <= r; k++)
//	{
//		if ((j > r) || (i <= q) && (a[i] <= a[j]))
//			t[k] = a[i++];
//		else
//		{
//			t[k] = a[j++];
//			c += q - i + 1;
//		}
//	}
//	for (i = p; i <= r; i++)
//		a[i] = t[i];
//	return c;
//}
//int Merge_sortC(int a[], int p, int r)
//{
//	if (p < r)
//	{
//		int q = p + (r - p) / 2;
//		return Merge_sortC(a, p, q) + Merge_sortC(a, q + 1, r) + Merge_sort(a, p, q, r);
//	}
//	else
//		return 0;
//}
//int main()
//{
//	int arr[5] = { 2,3,8,6,1 };
//	int c = Merge_sortC(arr, 0, 4);
//	printf("%d", c);
//	return 0;
//}



// 函数增长
//   虽然有时能确定一个算法的精确运行时间，但是通常不值得计算获得多余精度。
//   当输入规模足够大时，只与运行时间的增长量级有关时，研究算法的渐进效率。

// 3.1 渐进记号
//   用来描述算法渐进运行时间的记号根据定义域为自然数集N的函数来定义。 （对整数输入规模）
//   但采用渐进记号更为方便。（目的还是为了简化）

// 3.1.1 渐进记号、函数与运行时间
//   如插入排序，其最坏运行时间可写为函数T(n)=ann+bn+c,使用渐进记号o(nn)来描述它。
//   除时间函数外，渐进记号还可以描述算法的其他方面，如：空间数量，甚至是与算法无关的函数。
//   使用渐进记号来描述算法运行时间，不光是最坏运行时间，更希望是对所有输入的，因此有完全适合任何输入的运行时间的渐进记号。
//   3.1.1.1 theta记号
//   对于一个给定函数g(n),用theta(g(n))来表述以下函数的集合：
//   theta(g(n)) = {f(n):存在正常量c1,c2和n0，使得对所有n >= n0,有0 <= c1g(n) <= f(n) <= c2g(n)}
//      解读：若存在正常数c1和c2，使得对于足够大的n，函数f(n)能夹入c1g(n)和c2g(n)之间，则f(n)属于集合o(g(n))。
//            因为theta(g(n))是一个集合，，所以f(n)是它的成员，可以记为f(n)属于theta(g(n))，替代记为f(n)=tehta(g(n))
//            类似于夹逼准则，对所以n>=n0,f(n)在常量因子内等于g(n),称g(n)是f(n)的一个渐进紧确界。
//            定义要求，每个成员f(n)均渐进非负（c>0 nn>0,f夹在两者之间必非负）
//   简单记忆：只保留最高次项。 准确定义：如上。
//   Prove:  c1nn <=   ann+bn+c    <= c2nn    // 必有a>0
//           c1   <=  a+b/n+c/nn   <= c2      // 对不同n，可确定不同c1、c2,反之亦可。
//           c1/a <=  1+b/an+c/ann <= c2/a    // 进一步，最高次项的系数也可以忽略。
//          一般性的，对任意d阶多项式p(n),有p(n)=o（n的d次方）
//   3.1.1.2 O记号
//   相对theta记号给出一个函数的上界和下界，当只有一个渐进上界时，使用O记号。
//   对于一个给定函数g(n),用O(g(n))来表述以下函数的集合：
//   O(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0,有0 <= f(n)<= cg(n)}
//      解读：给出函数的上界，即对n0及其右边的所有n值，f(n) <= cg(n)
//            记f(n)=O(g(n)). 注意f(n)=o(g(n))中包含f(n)=O(g(n))。
//            当使用f(n)=O(g(n))时，仅仅要求g(n)的某个常数倍是f(n)的上界，但这个上界并不一定紧确。
//            使用O记号描述上界，可以仅通过算法的总体结构来描述算法运行时间,但由于输入变化，其最坏运行时间为O(nn)，但其他情况下不是。
//   3.1.1.3 Omiga记号
//   Omiga记号提供了函数下界。
//   对于一个给定函数g(n),用Omiga(g(n))来表述以下函数的集合：
//   Omiga(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0，有0 <= cg(n) <= f(n)}
//      解读：给出函数的上界，即对n0及其右边的所有n值，cg(n) <= f(n)

// 3.1.2 定理3.1
//   对于任意两个函数f(n)和g(n),有f(n)=o(g(n))。当且仅当f(n)=O(g(n))且f(n)=Omiga(g(n)).
//   对于ann+bn+c=0(nn)，实际应通过定理3.1从渐进确界获取渐进上下界，用渐进上界和下界证明渐进确界。
//   算法的最佳情况运行时间为Omiga，最坏运行情况时间为O，所以算法运行时间就在两者确定的渐进确界之间，需要时间为o

// 3.1.3 等式和不等式中的渐进记号
//   渐进记号可以用于数学公式中。
//   当渐进记号独立于等式或不等式一侧时，已经明确等号所指的集合关系。但渐进记号出现于在某个公式中时，将其解释为匿名函数。
//      如：2nn+3n+1=2nn+theta(n) 意为 2nn+3n+1=2nn+f(n)  f(n)为theta(n)中的某个函数。称f(n)为匿名函数。
//          总之利用渐进记号，消除等式中无关杂项（多为低阶项）。
//          一个表达式中匿名函数的数目可以理解为等于渐进记号出现的次数。
//   当渐进记号出现在等式一侧时，如： 2nn+theta(n)=theta(nn)
//         无论怎样选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。
//         等式右边是等式左边的进一步简化版。
//   3.1.3.1 o记号
//     O记号提供的渐进上界可能不是紧确的。如：2nn=O(nn)是紧确的 2n=O(n)却不是。
//     因此采用o记号来表示一个非渐进紧确的上界。 对于一个给定函数g(n),用o(g(n))来表述以下函数的集合：
//     o(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0,有0 <= f(n)< cg(n)}
//     极限n趋于无穷，f(n)/g(n)=0,可以作为o记号的定义。
//   3.1.3.2 w记号
//     w记号于Omiga记号的关系类似o记号与O记号的关系。 用w记号表示一个非渐进紧确的下界。
//     对于一个给定函数g(n),用w(g(n))来表述以下函数的集合：
//     w(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0，有0 <= cg(n) < f(n)}
//     极限n趋于无穷，f(n)/g(n)=无穷,可以作为o记号的定义。
//     也可以利用o记号定义： f(n) belong w(g(n))     only when     g(n) belong o(f(n))
//   3.1.3.3 应用
//     实数的许多关系性质也适用于渐进比较。 假定f(n)、g(n)渐进为正。
//     1 传递性
//       f(n)=theta(g(n))  and   g(n)=theta(h(n))    so   f(n)=theta(h(n))
//       f(n)=O(g(n))      and   g(n)=O(h(n))        so   f(n)=O(h(n))
//       f(n)=Omiga(g(n))  and   g(n)=Omiga(h(n))    so   f(n)=Omiga(h(n))
//       f(n)=o(g(n))      and   g(n)=o(h(n))        so   f(n)=o(h(n))
//       f(n)=w(g(n))      and   g(n)=w(h(n))        so   f(n)=w(h(n))
//     2 自反性
//       f(n) = theta(f(n))
//       f(n) = O(f(n))
//       f(n) = Omiga(f(n))
//     3 对称性
//       f(n) = theta(g(n))  only when  g(n) = theta(f(n))
//     4 转置对称性
//       f(n) = O(g(n))      only when  g(n) = Omiga(f(n))
//       f(n) = o(g(n))      only when  g(n) = w(f(n))
//     5 类比
//       O      a<=b  ;   o  a<b
//       Omiga  a>=b  ;   w  a>b
//       theta  a=b
//     6 三分性
//       对任意两个实数a，b，必存在三种关系中的某一种:a<b,a=b,a>b
//       但对于函数并不一定，即不是所有函数都可以渐进比较。


// test
// 3.1.1 
//   c1f(n) <= f(n) <= c2f(n)
//   c3g(n) <= g(n) <= c4g(n)
//   不妨设f(n) >= g(n)，则max(f(n),g(n))=f(n)
//   所以存在c5,c6，满足c5（f(n)+g(n)) <= f(n)=max(f(n),g(n)) <= c6(f(n)+g(n))
//   即证max(f(n),g(n))  =  theta(f(n)+g(n))

// 3.1.2
//   将（n+a）的b次方，多项式展开得，最高次项为n的b次方.
//   所以（n+a）的b次方 = theta(n的b次方)

// 3.1.3
//   O记号代表算法运行时间上限，与表述“运行时间至少”相矛盾。

// 3.1.4
//   2的(n+1)次方 = 2x2的n次方 = O(2的n次方) 成立 
//   2的2n次方    = 2的n次方 x 2的n次方 不等于 cx2的n次方  不成立

// 3.1.5 
//   因为 f(n) = theta(g(n))
//   所以 f(n)满足 c1g(n) <= f(n) <= c2g(n)
//   即同时满足  c1g(n) <= f(n)      ,   f(n) <= c2g(n)
//   即同时满足  f(n) = Omiga(g(n))  ,   f(n) = O(g(n))
//   所以 f(n) = theta(g(n)) 与 f(n) = Omiga(g(n))，f(n) = O(g(n))同时成立 两者等价。

// 3.1.6
//   类3.1.5证明。 Omiga(g(n))代表算法下界（最好情况运行时间），O(g(n))代表算法上界（最坏情况运行时间）

// 3.1.7
//   反证法  设存在f(n) = o(g(n))∩w(g(n))
//   则f(n)满足 f(n)<c1g(n)  且 f(n)>c2g(n)>=0
//   因为c1,c2是任意常数，令c1=c2，则 cg(n)<f(n)<cg(n)
//   不存在f(n)满足上不等式，矛盾，故o(g(n))∩w(g(n))为空集。

// 3.1.8
//   记号有两个参数的情况（n,m）
//   O(g(n,m)) = {f(n,m):存在正常量c、n0和m0,使得对所有n>=n0或m>=m0,有0 <= f(n,m) <= cg(n,m)}
//   Omiga(g(n,m)) = {f(n,m):存在正常量c、n0和m0,使得对所有n>=n0或m>=m0,有0 <= cg(n,m) <= f(n,m)}
//   theta(g(n,m)) = {f(n,m):存在正常量c1、c2、n0和m0,使得对所有n>=n0或m>=m0,有0 <= c1g(n,m) <= f(n,m) <= c2g(n,m)}


// 3.2 标准记号与常用函数
// 3.2.1 单调性
//   m<=n f(m)<=f(n),则函数f(x)单调递增     ; m<=n f(m)>=f(n)，则函数f(x)单调递减。
//   m<n  f(m)<f(n) ,则函数f(x)严格单调递增 ; m<n  f(m)>f(n)，则函数f(x)严格单调递减。

// 3.2.2 向下取整与向上取整
//   [x]表示小于或等于x的最大整数（读作x的向下取整）； [X]表示大于或等于x的最大整数（读作x的向上取整）
//   对所有实数x： x-1 < [x] <= x <= [X] < x+1
//   对任意整数n： [n/2] + [N/2] = n
//   对任意实数x>=0和整数a,b>0: [[X/A]/B] = [X/AB]
//                              [[x/a]/b] = [x/ab]
//                              [A/B]     <= (a+(b-1))/b
//                              [a/b]     >= (a-(b-a))/b
//   向下取整和向上取整函数都是单调递增的。

// 3.2.3 模运算
//   对任意整数a和任意正整数n，a mod n的值就是商a/n的余数：
//                             a mod n = a - n[a/n]
//                             0 <= a mod n < n
//   a mod n = b mod n时，记a=b(mod n) 称模n时，a等价于b。（即a模n与b模n有相同的余数）

// 3.2.4 多项式
//   给定一个非负整数d，n的d次多项式为p(n) = 求和(i=0到d)ai(n的i次方)
//   其中ai为多项式系数且ad不等于0
//   一个多项式为渐进正的 当且仅当ad>0，有p(n)=theta(n的d次方)。
//   对任意实常量a>=0,函数n的a次方单调递增；对任意实常量a<=0,函数n的a次方单调递减。
//   若对某常量k，有f(n)=O(n的k次方),则称函数f(n)是多项式有界的。

// 3.2.5 指数
//   n的b次方 = o(a的n次方)  (a>0)
//   对任意实数x:  e的x次方 >= 1+x  (x=0时取等号)
//   当|x|<=1时 :  1+x <= e的x次方 <= 1+x+xx  
//   当x趋于0时 :  e的x次方 = 1+x+theta(xx)

// 3.2.6 对数
//   对x>-1 : x/(1+x) <= ln(1+x) <= x  (x=0时取等号)
//   对任意常量a>0 : (lgn)的b次方 = o(n的a次方)

// 3.2.7 阶乘
//   n! = 1        n=0
//      = n(n-1)!  n>0
//   n! = 1x2x3x......xn
//   阶乘函数的一个弱上界是n! <= n的n次方。 因为阶乘中每一项小于等于n
//       斯特林近似公式： n! = 根号下(2pien) x (n/e)的n次方 x (1+theta(1/n))  给出一个更紧确的上界和下界。
//   对所有n>=1  n! = 根号下(2pien) x (n/e)的n次方 x e的an次方 。  其中 1/(12n+1) < an < 1(12n)

// 3.2.8 多重函数
//   f(i)(n)表示函数f(n)重复i次作用于一个初值n上
//   f(i)(n) = n            i=0
//           = f(f(i-1)(n)) i>0

// 3.2.9 多重对数函数
//   lg*n = min{i>=0: lg(i)n<=1}

// 3.2.10 斐波那契数
//   F0 = 0
//   F1 = 1
//   Fi = Fi-1 + Fi-2  i>=2
//   斐波那契数与黄金分割率及其共轭数有关，是方程xx=x+1的两个根
//   Fi = (黄金分割率i - 其共轭数i)/根号5 = [黄金分割率i/根号5 + 1/2]


// test
// 3.2.1 证明单调性
//   设a,b是定义域上任意两点，且a<b
//   因为f(n),g(n)单调递增，所以f(a)<=f(b),g(a)<=g(b)
//   所以f(a)+g(a)<=f(b)+g(b),即函数f(n)+g(n)单调递增
//   所以f(g(a))<=f(g(b)),即函数f(g(n))单调递增
//   若f(n),g(n)>=0,则0<=f(a)g(a)<=f(b)g(b),则函数f(n)g(n)单调递增。

// 3.2.2 证明a的logb(c) = c的logb(a)
//   等式两端同取logc：logb(c)logc(a)     logb(a)logc(c)
//                     logb(a)       =    logb(a) 等式成立，即证

// 3.2.3 证明lg(n!) = theta(nlgn)
//   lg(n!)=lg1 + lg2 + ... +lgn <= lgn + lgn + ... +lgn = nlgn
//   所以lg(n!) = theta(nlgn)
//   n! = 1x2x...xn < nxnx...xn = n的n次方,所以n!= o(n的n次方)
//   n! = 1x2x3x4...xn > 2x2x2x...x2 =2的n次方，所以n! = w(2的n次方)

// 3.2.4 证明[lgN]!无界，[lg(lgN)]!有界
//   首先，f(n)多项式有界的充分必要条件是 lgf(n) = O(lgn) （存在常数c和n0，当n>=n0时，f(n)<c*n的k次方）
//   1 设f(n)=(lgn)!   存在常数c和n0，当n>=n0时，lg(f(n)) >= c(lgn)lg(lgn)
//     由于lg(lgn)是单调递增函数，总可以在n >= n0的范围内找到n >= n1，使得clg(lgn) >= 1
//     则此时lg(f(n)) >= lgn，并不能满足lgf(n) = O(lgn).  所以(lgn)!并不是多项式有界函数。
//   2 设f(n)=(lglgn)! 由公式3.2.3，lg(n!)=theta(nlgn)，得lg(f(n))=lg((lglgn)!) = theta(lg(lgn(lglglgn)))
//     因为对于任意的n > 1，lglglgn < lglgn，则存在常数c和n0，使得n >= n0时，lg(f(n)) <= c(lglgn)²
//     又因为任意多项式函数都比任意多对数函数增长快，所以c(lglgn)² = O(lgn), 所以lg(f(n)) = O(lgn),则f(n) = (lglgn)!多项式有界。

// 3.2.5 
//   lg*(lgn)=lg*n+1   lg(lg*n)为lg*n的对数函数，因而lg*(lgn)渐进更大些

// 3.2.6
//   黄金分割率及其共轭数带入方程xx=x+1即证

// 3.2.8
//    证明klnk = theta(n) 蕴含着k=theta(n/ln(n)).
//    当klnk = theta(n)时，则存在正常量c1, c2和n0,使得对所有n ≥ n0,有0 ≤ c1∗n ≤ nln(n) ≤ c2∗n 
//    此时n>=1,有0<=c1*n/(lnn) <= n <= c2*n/(lnn)，即证

// 3.1 
//   https://blog.csdn.net/victoryaoyu/article/details/76237944

// 3.2 相对渐进增长 （k>=1 e>0 c>1且均为常量）
//   (lgn)的k次方 <=   n的e次方
//   n的k次方     <=   c的n次方
//   根号n        no   n的sinn次方
//   2的n次方     >=   2的(n/2)次方
//   n的lgc次方   =    c的lgn次方
//   lg(n!)       =    lg(n的n次方)

// 3.3 根据渐进增长率排序 (g1=Omiga(g2)=Omiga(g3)=...=Omiga(g30))
//   2的(2的(n+1)次方)次方
//   2的(2的n次方)次方
//   (n+1)!
//   n!
//   e的n次方
//   n(2的n次方)
//   2的n次方
//   (3/2)的n次方
//   n的(lglgn)次方 = (lgn)的lgn次方
//   (lgn)!
//   n的3次方
//   n的平方 = 14的(lgn)次方
//   nlgn 近似于 lg(n!)
//   n = 2的lgn次方
//   (根号2)的lgn次方
//   2的根号2lgn次方
//   (lgn)的平方
//   lnn
//   根号lgn
//   lnlnn
//   2的(lg*n)次方
//   lg*n 近似于 lg*(lgn)
//   lg(lg*n)
//   1 = n的(1/lgn)
//   不是上述函数上界或下界的函数 (2的(2的(2的(n+1)次方))次方)的sinx次方

// 3.4 渐进记号的性质
// f(n) = O(g(n)) 不等价于 g(n) = O(f(n))   如 n=O(nn)
// f(n)+g(n) 不等于 theta(min{f(n),g(n)})   如 n+nn 不等于 theta(min{n,nn})
// f(n) = O(g(n)) 等价于 lg(f(n)) = O(lg(g(n)),其中对所有足够大的n，有lg(g(n))>=1且f(n)>=1
// f(n) = O(g(n)) 不等价于 2的f(n)次方=O(2的g(n)次方)  如 2n=O(n),4的n次方不等于O(2的n次方)
// f(n)>=1时，f(n) = O((f(n))的平方) ；f(n)<1时，不成立。
// f(n) = O(g(n)) 等价于 g(n) = Omiga(f(n))
// f(n) 不等于 theta(f(n/2))   如 n! 不等于 theta((n/2)!)
// f(n)+o(f(n)) = theta(f(n))

// 3.5 Omiga无穷：若存在正常量c，使得对无穷多个整数n，有f(n)>=cg(n)>=0，则称f(n)=Omiga无穷(g(n))
//   1 对渐进非负的任意两个函数f(n)和g(n),或者f(n)=O(g(n))或者f(n)=Omiga无穷(g(n))或者两者均成立。但Omiga替代Omiga无穷时，命题为假。
//     若f(n) 不等于 O(g(n)) ,则必有无穷多个正整数n，使f(n)>=cg(n)>=0,即f(n)=Omiga无穷成立。
//     若f(n) = theta(g(n)),则两者同时成立。
//     若用Omiga替代Omiga无穷则不一定成立，如n=Omiga无穷(n的sinn次方),但n不等于Omiga(n的sinn次方)
//   2 Omiga无穷替代Omiga
//     优点：Omiga无穷对下界要求更宽松，可以兼容更多情况。
//     缺点：Omiga无穷不是严格的渐进下界，实际意义不大。
//   3 O'：f(n)=O'(g(n)) only when  |f(n)|=O(g(n))
//     用O'替代O仍使用Omiga，对定理3.1没有影响。
//     因为f(n)=O(g(n))成立代表f(n)渐进非负，所有|f(n)|=f(n)。
//   4 定义软O记号，意指忽略对数因子的O：
//     软O(g(n)) = {f(n):存在正常量c,k,n0,使得对所有n>=n0,有0<=f(n)<=cg(n)(lg(n))的k次方}
//     类似定义软Omiga和软theta
//     软Omiga(g(n)) = {f(n):存在正常量c,k,n0,使得对所有n>=n0，有0<=cg(n)(lg(n))的k次方<=f(n)}
//     软theta(g(n)) = {f(n):存在正常量c1,c2,k1,k2,n0,使得对所有n>=n0,有0<=c1g(n)(lg(n))的k1次方<=f(n)<=c2g(n)(lg(n))的k2次方}

// 3.6 多重函数：将用于函数lg*的多重操作符*应用于实数集上的任意单调递增函数f(n).
//   对给定常量c属于R，定义多重函数fc*(n) = min{i>=0,f(i)(n)<=c}
//   该函数不必在所有情况下都良定义。值fc*(n)是为缩小其参数到c或更小所需函数f重复应用的次数。
//   对于每个函数f(n)和常数c，给出fc*(n)的一个尽量紧确的界。
//   f(n)          c          fc*(n)
//   n-1           0          theta(n)
//   lgn           1          theta(lg*n)
//   n/2           1          theta(lgn)
//   n/2           2          theta(lgn)
//   根号n         2          theta(lglgn)
//   根号n         1          无法收敛
//   n的1/3次方    2          theta(log3(lgn))
//   n/lgn         2          w(lglgn),o(lgn)



// 分治策略
// 分解、解决、合并。 子问题足够大时，递归求解，称之为递归情况；子问题足够小时，递归触底，进入基本情况。
// 有时除了与原问题完全一样的子问题外，还有不完全一样的将其归入合并步骤。
//   递归式
//     一个等式或不等式，通过更小的输入来描述一个函数。 子问题的规模不一定是原问题规模的一个固定比例。
//     求解递归式的方法：代入法、递归树法、主方法。
//   递归式技术细节
//     实际应用中会忽略递归式声明和求解一些技术细节。 如：向下取整或向上取整、边界条件。

// 4.1 最大子数组问题
//   以股票为例，利益最大化即最低价买入最高价卖出。
//   若最高价出现在最低价之前，则无法实现理想的利益最大化，因而实际的利益最大化是买入（不一定是最低价）和卖出（不一定是最高价）的差价最高。
//  4.1.1 暴力求解法
//    对可能的买进和卖出日期全部组合一边，从中遍历出最大值。 运行时间为Omiga(nn)
//  4.1.2 问题变换
//    不再从每日价格的角度看待数据，而是考虑每日价格变化。
//    第i天价格变化定义为：第i天和第i-1天的价格差。 将价格变化看做一个数组A，则问题转化成找A的和最大的非空连续子数组（最大子数组）。
//    最大子数组可能不止一个
//    目前该方法仍需检查（n-1，2）=theta(nn)个子数组，和暴力求解法近似.
//  4.1.3 分治策略
//    设寻找子数组A[low...high]的最大子数组。
//    将数组尽可能分成两个规模相等的子数组，分别找其内部的最大子数组。
//    最大子数组A[low...high]的任何连续子数组A[i...j]必然位于以下三种情况之一：
//      1 完全位于子数组A[low...high]中。
//      2 完全位于子数组A[mid+1...high]中。
//      3 跨越mid。
//      对于情况3，将数组分为左右两个数组，分别找出左右的最大子数组，再将它们合并即为所求。
//      Find_Max_Crossing_Subarray(A,low,mid,high)
//    1 left-sum = - 无穷
//    2 sum = 0
//    3 for i=mid downto low     // 从中点往左找最大子数组
//    4     sum = sum + A[i]     // 求子数组的和
//    5     if sum >left-sum     // 如果求和大于之前的最大值
//    6        left-sum = sum    // 赋值，即为当前左数组的最大子数组
//    7        max-left = i      // 记录左边界
//    8 right-sum = -无穷        // 原理同求左数列
//    9 sum = 0
//   10 for i=mid+1 to high
//   11     sum = sum + A[i]
//   12     if sum>right-sum
//   13        right-sum = sum
//   14        max-right = i
//   15 retrun (max-left,max-right,left-sum+right-sum)
//   上述过程花费theta(n)的时间
//   下面用分治法求解最大子数组问题
//   Find_Maximum_Subarray(A,low,high)
//  1  if high == low
//  2     return (low,high,A[low])  // 数组只有一个元素
//  3  else mid = [(low+high)/2]    // 中点位置向下取整
//  4       (left-low,left-high,left-sum) = Find_Maximum_Subarray(A,low,mid)               // 情况1，求左数组中的最大子数组
//  5       (right-low,right-high,right-sum) = Find_Maximum_Subarray(A,mid+1,high)         // 情况2，求右数组中的最大子数组
//  6       (cross-low,cross-high,cross-sum) = Find_Max_Crossing_Subarray(A,low,mid,high)  // 情况3，求跨mid最大子数组
//  7  if left-sum >= right-sum and left-sum >= cross-sum         // 如果左数组的最大子数组最大，则它为整个数组的最大子数组
//  8     return (left-low,left-high,left-sum)
//  9  elseif right-sum >= letf-sum and right-sum >= cross-sum    // 如果右数组的最大子数组最大，则它为整个数组的最大子数组
// 10      return (right-low,right-high,right-sum)
// 11   else return (cross-low,cross-high,cross-sum)               // 如果cross数组的最大子数组最大，则它为整个数组的最大子数组
//  4.1.4 分治算法分析
//    1、2行花费常量时间。 T(1) = theta(1)
//    3花费常量时间。
//    4、5解决两个规模为n/2的子问题，每个子问题花费T(n/2)
//    6调用Find_Max_Crossing_Subarray,花费theta(n)
//    7-11花费theta(1)时间
//    总体花费T(n) = theta(1) + 2T(n/2) + theta(n) +theta(1) = 2T(n/2) + theta(n)
//    递归式： T(n) = theta(1)            n=1
//                  = 2T(n/2) + theta(n)  n>1
//    利用主方法，求解时间为T(n) = theta(nlgn)   (或者可以用递归树理解)


// test 
// 1 当A的所有元素为负数时，Find_Maximum_Subarray返回什么？
//   返回数组最大元素

// 2 对最大子数组，编写暴力求解方法的伪代码，运行时间为theta(nn)
//   Sum(A,low,high)
//     sum = 0
//     for i=low to high
//         sum += A[i]
//     return sum
// 
//   Find_Max_Subarray(A,n)
//     max_sum = -无穷
//     max_left = 0
//     max_right = 0
//     for i=1 to n
//       for j=i to n
//         temp_sum = sum(A,i,j)
//         if temp_sum > max_sum
//            max_sum = temp_sum
//            max_left = i
//            max_right = j
//     return (max_left,max_right,max_sum)

// 3 暴力算法和递归算法的性能交叉点
//   theta(nn) = theta(nlgn) 解出n0
//   在0-n0使用暴力算法，在n0到正无穷使用递归算法

// 4 修改最大子数组定义，允许空子数组为结果，其和为0.
//   if low = high and a[high]<0
//      return (-1,-1,0)

// 5 最大子数组的非递归、线性时间算法。
//   若A[1...j]为最大子数组，求A[1...j+1]的最大子数组。
//    A[1...j+1]的最大子数组要么是A[1...j]的最大子数组，要么是A[i...j+1].
//   Find_Max_Subarray(A,n)
//    low = 1
//    high = 1
//    sum = A[1]
//    for j=2 to n
//        temp_sum = 0
//        sum1 = A[j]
//        low1 = j
//        high1 = j
//        for i=j downto 1
//            temp_sum += A[i]
//            if temp_sum > sum1
//               sum1 = temp_sum
//               low1 = i
//        if sum1 > sum
//           sum = suum1
//           low = low1
//           high = high1
//     return(low,high,sum)


// 4.2 矩阵乘法的Strassen算法
//   需要计算nn个矩阵元素，每个元素是n个值的和。 给出伪代码如下：
//   Square_Matrix_Multiply(A,B)
//     n = A.rows
//     let C be a new nxn matrix
//     for i=1 to n
//         for j=1 to n
//             cij = 0
//             for k=1 to n
//                 cij = cij + aik x bik
//     return C
//   花费theta(nnn)时间
//   但使用Strassen的nxn矩阵相乘的递归算法，其运行时间为theta(n的lg7次方)

// 4.2.1 一个简单的分治算法
//   将n x n矩阵划分成4个n/2 x n/2的子矩阵构成的矩阵
//   对应C11 = A11 x B11 + A12 x B21，即每个公式对应两对n/2 x n/2矩阵乘法的加法。
//   直接的递归分治算法伪代码如下：
//   Square_Matrix_Multiply_Recursive(A,B)
//     n = A.rows
//     let C be a new nxn matrix
//     if n==1
//        c11 = a11 x b11
//     else partition A,B and C(利用下标)
//        c11 = Square_Matrix_Multiply_Recursive(A11,B11) + Square_Matrix_Multiply_Recursive(A12,B21)
//        c12 = Square_Matrix_Multiply_Recursive(A11,B12) + Square_Matrix_Multiply_Recursive(A12,B22)
//        c21 = Square_Matrix_Multiply_Recursive(A21,B11) + Square_Matrix_Multiply_Recursive(A22,B21)
//        c22 = Square_Matrix_Multiply_Recursive(A21,B12) + Square_Matrix_Multiply_Recursive(A22,B22)
//     return C
//  递归式 T(n) = theta(1)                        n=1
//              = theta(1) + 8T(n/2) + theta(nn)  n>1

// 4.2.2 strassen方法
//   在分治算法的基础上，只递归七次而不是8次。
//   步骤：
//     1 将A、B、C分解为n/2 x n/2子矩阵，theta(1)
//     2 创建10个n/2 x n/2的矩阵，每个矩阵保存1中两个子矩阵的和或差,theta(nn)
//     3 用1、2创建的矩阵，递归计算七个矩阵的积。
//     4 通过3计算的矩阵不同组合加减运算，计算出C的子矩阵，theta(nn)
//   步骤2中：S1=B12 - B22  S2=A11 + A12  S3=A21 + A22  S4=B21 - B11  S5=A11 + A22
//            S6=B11 + B22  S7=A12 - A22  S8=B21 + B22  S9=A11 - A21  S10=B11 + B12
//   步骤3中：P1=A11 x S1   P2=S2 x B22  P3=S3 x B11  P4=A22 x S4  P5=S5 x S6  P6=S7 x S8  P7=S9 x S10
//   步骤4中：C11 = P5 + P4 - P2 + P6 = A11 x B11 + A12 x B21
//            C12 = P1 + P2 = A11 x B12 + A12 x B22
//            C21 = P3 + P4 = A21 x B11 + A22 x B21
//            C22 = P5 + P1 - P3 - P7 = A22 x B22 + A21 x B12
//   递归式：T(n) = theta(1)             n=1
//                = 7T(n/2) + theta(nn)  n>1
//   递归式解为：T(n) = theta(n的lg7次方)


// test
// 1 使用Strassen算法计算矩阵乘法
//   S1=8-2=6 S2=1+3=4 S3=7+5=12 S4=4-6=-2 S5=1+5=6
//   S6=6+2=8 S7=3-5=-2 S8=4+2=6 S9=1-7=-6 S10=6+8=14
//   P1=6 P2=8 P3=72 P4=-10 P5=48 P6=-12 P7=-84
//   C11=26 C12=14 C21=62 C22=66

// 2 Strassen算法伪代码
//   Strassen(A,B)
//    let C be a new nxn matrix
//    if A.row == 1
//       C = A * B
//    else partition A,B,C
//       S1=B12 - B22  
//       S2=A11 + A12  
//       S3=A21 + A22 
//       S4=B21 - B11
//       S5=A11 + A22
//       S6=B11 + B22  
//       S7=A12 - A22
//       S8=B21 + B22  
//       S9=A11 - A21  
//       S10=B11 + B12
//       P1=A11 x S1   
//       P2=S2 x B22  
//       P3=S3 x B11
//       P4=A22 x S4
//       P5=S5 x S6
//       P6=S7 x S8
//       P7=S9 x S10
//       C11 = P5 + P4 - P2 + P6
//       C12 = P1 + P2
//       C21 = P3 + P4
//       C22 = P5 + P1 - P3 - P7
//    return C

// 3 修改strassen算法，使之适应矩阵规模不是2的幂的情况。
//   将矩阵扩展成2的[lgN] x 2的[lgN]矩阵，缺少的地方补0.

// 4 用k次乘法操作完成两个3x3矩阵相乘，可以在theta(n的lg7)时间内完成nxn矩阵相乘，满足条件k最大为多少，运行时间如何？
//   先将3x3矩阵补成4x4矩阵，k=4的lg7次方<=49

// 5 V.Pan算法，132464次乘法完成68x68矩阵乘法，143640次乘法完成70x70矩阵乘法，155424次乘法完成72x72矩阵乘法。
//   72x72矩阵会得到最佳渐进运行时间，其性能优于strassen算法。

// 6 strassen算法作为子进程处理kn x n矩阵乘n x kn矩阵，最快耗时？前后互换呢？
//   将A、B矩阵拆分为k个nxn矩阵，AxB=knxkn的矩阵，内部每个子矩阵相乘用strassen算法，theta(kkn的lg7次方)
//   反之，AxB=nxn的矩阵，theta(kn2的lg7次方)

// 7 三次实数乘法完成两个复数的相乘，接受abcd作为输入，输出实部和虚部。
//   A = (a + b)*c
//   B = (c + d)*b
//   C = (b - a)*d
//   (a + bi)*(c + di) = (A - B) + (B - C)i


// 4.3 用代入法求递归式
//   1 猜测解的形式
//   2 用数学归纳法求出解中的常数，并证明解的正确性                 
//   举例： 递归式T(n) = 2T([n/2]) + n,猜测其解为T(n)=O(nlgn)
//   证明：选择常数c>0，有T(n) <= cnlgn.
//         假设上界对所有m<n成立，对于m=[n/2],有T([n/2]) <= c[n/2]lg([n/2]).
//         so T(n) <= 2(c[n/2]lg([n/2])) + n <= cnlg(n/2) + n
//                  = cnlgn - cnlg2 + n
//                  = cnlgn - cn + n
//                 <= cnlgn (when c>=1)

// 4.3.1 做出好的猜测
//   1 靠经验、创造力和递归树。
//   2 先估计一个宽松的上下界，再逐步逼近渐进紧确界

// 4.3.2 微妙的细节
//   有时猜出了递归式的渐进界，但证明失败。问题在于归纳假设不够，应修改猜测，减去一个低阶项可能起效。
//   例：T(n) <= T([n/2]) + T([N/2]) + 1
//       猜测T(n) = O(n) T(n) <= cn,证明失败
//       再猜测T(n) <= cn - d
//             T(n) <= c[n/2]-d + c[N/2]-d + 1 <= cn- 2d + 1 <= cn - d  (when d>=1) 证明成立

// 4.3.3 避免陷阱
//   使用渐进符号容易出错，要证出与归纳假设严格一致的格式。
//   如：T(n) <= 2(c[n/2]) + n <= cn + n 不能证明T(n) <= cn 即T(n) = O(n)

//  4.3.4 改变变量
//    用代数运算将一个未知的递归式变成熟悉的形式。
//    如：T(n) = 2T([根号n]) + lgn
//        令 m = lgn 得到T(2的m次方) = 2T([2的m/2次方]) + m
//       变量代换后,S(m) = 2S(m/2) + m 有 S(m)=O(mlgm)
//       so T(n) = T(2的m次方) = S(m) = O(mlgm) = O(lgn lglgn)


// test
// 1 证明T(n) = T(n-1) + n的解为O(nn)
//   即证T(n) <= cnn - d
//   T(n) = T(n-1) + n
//       <= c(n-1)(n-1)+ n
//        = cnn - (2c-1)n + c  ( -(2c-1)n + c < 0)
//       <= cnn (when c>=n/(2n+1) 取c=1)

// 2 证明T(n) = T([N/2]) + 1的解为O(lgn)
//   即证T(n) <= clgn
//   T(n) = T([N/2]) + 1
//       <= clg([N/2]) + 1  (when n>=2,1<=[N/2]<=2n/3 )
//        = clgn + clg(2/3) + 1 (令 -clg(2/3) + 1 <0)
//       <= clgn (when c>1/lg(2/3))

// 3 证明T(n) = 2T([n/2]) + n的解为theta(nlgn)
//   即证c1[n]lg[n] <= T([n]) <= c2[n]lg[n]
//   对左不等式：
//   T(n) >= 2c[n/2]lg[n/2] + n
//        >= 2c(n/3)lg(n/3) + n
//         = (2/3)cnlgn - (2/3)cnlg3 + n (任意0<c<3/(2lg3))
//        >= (2/3)cnlgn

// 4 做出不同假设来克服T(n) = 2T([n/2]) + n的边界条件T(1) = 1
//   假设T(n) <= cnlgn + d (d>0)

// 5 证明归并排序的严格递推式的解为theta(nlgn)
//   任意m<n，存在c1、c2满足：c2mlgm <= T(m) <= c1mlgm
//   右不等式：T(n) <= 2c1[N/2]lg[N/2] + theta(n)
//                  <= 2(2/3)c1nlg(2n/3) + theta(n)
//                   = (4/3)c1nlgn + (4/3)c1nlg(2/3) + theta(n)
//                   = (4/3)c1nlgn
//    左不等式:T(n) >= 2c2[N/2]lg[N/2] + theta(n)
//                  >= 2(1/3)c2nlgn +theta(n)
//                   = (2/3)c2nlgn - c2(2/3)nlg3 + theta(n)
//                   = (2/3)c2nlgn

// 6 证明T(n) = 2T([n/2]+17) + n的解为O(nlgn)
//   即证T(n) <= cnlgn
//   T(n) = 2T([n/2]+17) + n
//       <= 2c([n/2]+17)lg([n/2]+17) + n (when n>=102,n/2+17>=2/3n)
//       <= (4/3)cnlgn + (4/3)cnlg(2/3) + n
//       <= (4/3)cnlgn (when c>=10)

// 7 使用主方法可以证明T(n) = 4T(n/3) + n的解为theta(n的log3(4)次方)
//   说明如何通过减去一个低阶项完成代入法证明。
//   不减低阶项时T(n) <= 4c((n/3)的log3(4)次方) + n，结构不严格一致，证明失败。
//   假设T(n) <= c(n的log3(4)次方) - dn
//   T(n) = 4T(n/3) + n
//       <= 4c((n/3)的log3(4)次方) - d(n/3) + n
//        = 4c(n的log3(4)次方) - (4/3)dn + n
//        = 4c(n的log3(4)次方) - (4d/3 - 1)n
//       <= 4c(n的log3(4)次方) - dn (when d>3)

// 8 使用主方法可以证明T(n) = 4T(n/2) + n的解为theta(nn)
//   说明如何通过减去一个低阶项完成代入法证明。
//   不减低阶项时T(n) <= cnn + n,结构不严格一致，证明失败。
//   假设T(n) <= cnn - dn
//   T(n) <= cnn  - dn + n
//         = cnn + (1-d)n (令1-d<0)
//        <= cnn (when d>1)

// 9 利用改变变量方法求解递归式T(n) = 3T(根号n) + lgn
//   令m = lgn,则n = 2的m次方，代入原式：T(2的m次方) = 3T(2的(m/2)次方) + m
//   令S(m) = T(2的m次方),则S(m) = 3S(m/2) + m
//   假设S(m) = theta(mlgm),c2mlgm <= S(m) <= c1mlgm
//   递归得c2(m/2)lg(m/2) <= S(m/2) <= c1(m/2)lg(m/2)
//   (3/2)c2mlgm - (3/2)c2mlg2 + n <= (3/2)c2mlg(m/2) + m <= S(m) <= (3/2)c1mlg(m/2) + m <= (3/2)c1mlgm - (3/2)c1mlg2 + m
//   when c1 >= 2/(3lg2) , c2 <= 2/(3lg2)
//     (3/2)c2mlgm <= S(m) <= (3/2)c1mlgm
//   so S(m) = theta(mlgm)
//   T(n) = T(2的m次方) = theta(lgn(lglgn))


// 4.4 用递归树求解递归式
//   画出递归树是设计好的猜测的一种简单而直接的方法。
//   一个结点表示一个单一子问题的代价，子问题对应某次递归函数的调用。
//   将树中每层代价求和，所有层代价总和即为总代价。
//   递归树最适合用来生成好的猜测，再用代入法验证猜测。
//   在建立递归树时，往往要忽略部分细节，来得到一个上界。


// test
// 1 对T(n) = 3T([n/2])+n,利用递归树确定一个好的渐近上界，用代入法验证。
//   假设n是2的幂
//   T(n) = n + (3/2)n + ((3/2)的平方)n + ... + ((3/2)的(lgn - 1)次方)n + theta(n的lg3次方)
//        = 求和(0到lgn - 1)(3/2)的i次方n + theta(n的lg3次方)
//        = 2(3的lgn次方) - 2n + theta(n的lg3次方)
//        = O(n的lg3次方)
//   证明T(n) <= cn的lg3次方 + n
//   T(n) = 3T(n/2) + 2n
//       <= 3c(n/2)的lg3次方 + 2n
//       <= cn的lg3次方 + 2n

// 2 对T(n) = T(n/2) + nn,利用递归树确定一个好的渐近上界，用代入法验证。
//   T(n) = nn + (1/4)nn + ((1/4)的平方)nn + ... + ((1/4)的(lgn - 1)次方)nn + T(1)
//        = 求和(0到lgn -1)((1/4)的i次方)nn + T(1)
//        < nn求和(0到无穷)((1/4)的i次方) + T(1)
//        = (4/3)nn + T(1)
//        = O(nn)
//   证明T(n) <= cnn
//   T(n) = T(n/2) + nn
//       <= (c/4)nn + nn
//        = (c/4 + 1)nn
//       <= cnn (when c > 4/3)

// 3 对T(n) = 4T(n/2+2) + n,利用递归树确定一个好的渐近上界，用代入法验证。
//   T(n) = n + (4(1/2)n+8) + (16(1/4)n+48) +...+ ((4的lgn - 1次方)((1/2)的lgn - 1次方))n + (4的lgn - 1次方)((1/2)的lgn - 3次方+...+2) + theta(nn)
//        = n求和(0到lgn - 1)(2的i次方) + 求和(1到lgn - 1)(4的(i+1)次方 - 2的(i+2)次方) + theta(nn)
//        = nn - n + (1/3)(4nn - 8) + 4n - 8 +theta(nn)
//        = theta(nn)
//   证明T(n) <= cnn + 2n
//   T(n) = 4T(n/2+2) + n
//        < 4c(n/2)(n/2) + 2(n/2) + n
//        = cnn + 2n

// 4 对T(n) = 2T(n-1) + 1,利用递归树确定一个好的渐近上界，用代入法验证。
//   T(n) = 1 + 2 + 4 + ... + 2的n-2次方 + theta(2的n-1次方) = theta(2的n次方)
//   证明T(n) <= c(2的n次方) + n
//   T(n) = 2T(n-1) + 1
//       <= 2c(2的n-1次方) + (n-1) + 1
//       <= c(2的n次方) + n

// 5 对T(n) = T(n-1) + T(n/2) + n,利用递归树确定一个好的渐近上界，用代入法验证。
//   不是完全二叉树，从lgn到n-1为非完全层。推测T(n) = O(2的n次方)
//   证明T(n) <= c(2的n次方) - 4n
//   T(n) = T(n-1) + T(n/2) + n
//       <= c(2的(n-1)次方 + 2的(n/2)次方) - 4(n-1) - 4n/2 + n
//       <= c(2的(n-1)次方 + 2的(n/2)次方) - 5n + 1  (when n > 1/4)
//       <= c(2的(n-1)次方 + 2的(n/2)次方) - 4n      (when n > 2)
//       <= c(2的m次方) - 4n

// 6 对T(n) = T(n/3) + T(2n/3) + cn,利用递归树论证解为Omiga(nlgn),其中c为常数。
//   递归树知道log3(n)后才开始不完全，每层代价都为cn
//   T(n) >= Omiga(nlog3(n)) = Omiga(nlgn)

// 7 对T(n) = 4T([n/2]) + cn,利用递归树解一个渐进紧确界，用代入法验证。
//   T(n) = cn + 2cn + 4cn +...+ (4的lgn - 1次方)(cn)/(2的lgn - 1次方) + theta(nn)
//        = cn求和(0到lgn - 1)(2的i次方) + theta(nn)
//        = cn(2的lgn次方 - 1) + theta(nn)
//        = theta(nn)
//   证明T(n) <= cnn + 2cn
//   T(n) = 4T([n/2]) + cn
//       <= 4c(n/2)(n/2) + 2cn/2 + cn
//        = cnn + 2cn
//   T(n) = 4T([n/2]) + cn
//       >= 4c(n/2)(n/2) + 2cn/2 + cn
//        = cnn + 2cn
//    so T(n) = theta(nn)

// 8 对T(n) = T(n-a) + T(a) + cn,利用递归树解一个渐进紧确解，用代入法验证。
//   T(n) = cn + cn + c(n-a) + c(n-2a) +...+ c(n-(n/a - 1)a + a) + theta(1)
//        = cnn/a + c(n/a -1)a - ca求和(1 to (n-a)/a-1)i + theta(1)
//        = tehta(nn)
//   证明T(n) <= cnn
//   T(n) = T(n-a) + T(a) + cn
//       <= c(n-a)(n-a) + caa + cn
//       <= cnn - cn(2a-1) + caa + ca (when a>=1,n>(aa+a)/(2a-1))
//       <= cnn
//   证明T(n) >= cnn
//   T(n) = T(n-a) + T(a) + cn
//       >= c(n-a)(n-a) + caa + cn
//        = cnn - 2an + 2caa + cn
//        = cnn + (c-2a)n + 2caa
//       >= cnn (when c>=2a,a>=0)
//   so T(n) = theta(nn)

// 9 对T(n) = T(an) + T((1-a)n) + cn,利用递归树解一个渐进紧确解.
//   T(n) <= cnlg(1/(1-a))n <= cnlgn (1-a <= 1/2)
//   T(n) = Omiga(nlgn)
//   证明T(n) <= dnlgn
//   T(n) = T(an) + T((1-a)n) + cn
//       <= danlg(an) + c(1-a)nlg((1-a)n) + cn
//        = danlgn + d(1-a)nlgn + danlga + d(1-a)nlg(1-a) + cn
//       <= dnlgn + (d(alga + (1-a)lg(1-a))+c)n
//       <= dnlgn (when d >= -c/(alga + (1-a)lg(1-a))
//   so T(n) = theta(nlgn)


// 4.5 用主方法求解递归式
//   为形式如T(n) = aT(n/b) + f(n) 的递归式，提供了一种“菜谱”式求解方法
//     其中，a>=1 b>=1，f(n) 是渐近正函数。
//   牢记三种情况，可以很容易求解很多递归式.
//   T(n) = aT(n/b) + f(n) 描述这样一种算法：
//        将规模为n的问题分解为a个子问题，每个子问题规模为n/b。
//        递归解决a个子问题，每个花费时间T(n/b).
//        f(n)包含了问题分解和合并的代价。
//   从技术正确性来看，该方法不是良定义，因为n/b可能不是整数，但可以用[]替换且不影响递归式渐近性质。

// 4.5.1 主定理
//   定理4.1（主定理） 令a>=1,b>1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式： T(n) = aT(n/b) + f(n)
//                     其中将n/b解释为[n/b]或[N/b],则T(n)有如下渐近界：
//                         1 若对某个常数e>0有f(n) = O(n的(logb(a-e)次方)，则T(n) = theta(n的logb(a)次方)。
//                         2 若f(n) = theta(n的logb(a)次方)，则T(n) = theta(n的(logb(a))次方lgn)。
//                         3 若对某个常数e>0有f(n) = Omiga(n的(logb(a+e))次方)，且对某个常数c<1和所有足够大的n有af(n.b)<=cf(n)，则T(n) = theta(f(n))。
//   对三种情况，都将 f(n) 与 n的logb(a)次方 进行比较。直观上，前者更大，解如情况3；后者更大，解如情况1，两者相等，解如情况2.
//   实际上，不是简单小于、大于即可，而要是多项式的渐近小于(相差因子n的e次方)、大于(满足正则条件af(n/b) <= cf(n))
//   三种情况之间还存在其他可能，在这些范围内不能使用主定理。
//   附：正则条件：指在陈述某个定理时，限定它的使用范围。如果超出这个范围，会导致定理不成立。

// 4.5.2 使用主方法
//   分析对应a、b的值，判断 f(n) 与 n的logb(a)次方 的渐近大小。
//   确定主定理的哪种情况成立，即可得到解。


// test
// 1 主方法求渐近紧确界
//   a T(n) = 2T(n/4) + 1        theta(n的(1/2)次方)
//   b T(n) = 2T(n/4) + 根号n    theta(n的(1/2)次方lgn)
//   c T(n) = 2T(n/4) + n        theta(n)
//   d T(n) = 2T(n/4) + nn       theta(nn)

// 2 Caesar教授想设计一个渐近快于Strassen算法的矩阵乘法。
//   采用分治法，将矩阵分解为n/4 x n/4的子矩阵，分解和合并花费theta(nn)时间。
//   需要创建多少个子问题才能击败Strassen算法？
//   T(n) = aT(n/4) + theta(nn) 求a的最大整数值。
//   Strassen: theta(n的lg7次方)
//   Caesar:   theta(n的log4(a)次方)
//   log4(a) < lg7  so a<=48

// 3 使用主方法证明，二分查找递归式T(n) = T(n/2) + theta(1) 的解时T(n) = theta(lgn)
//   a=1  b=2  n的lgb(a)=1=f(n)
//   so situation2：T(n) = theta(n的logb(a)次方lgn) = theta(lgn)

// 4 主方法能用于递归式T(n) = 4T(n/2) + nnlgn吗？ 给出一个渐近上界
//   a=4  b=2  n的lgb(a)= nn 
//   f(n) = nnlgn 渐近大于 nn,但不存在e>0,使f(n) = Omiga(n的logb(a+e)次方)
//   So can not prove.
//   用递归树求解：
//   T(n) = 求和(0 to lgn - 1)nn(lgn - i) + theta(nn)
//        = (1/2)nn(lgn)的平方 + theta(nn)
//        = O(nn(lgn)的平方) (when c>=1)


// 4.6 证明主定理
//   1 分析主递归式，简化定义n为b的幂次。
//   2 分析扩展到所有整数n，应用向下和向上取整的数学技巧。
//   3 稍微滥用渐近符号，用以描述b的幂上的函数行为。  当然，再有限值域上应用渐近符号应当小心，避免错误结论。

// 4.6.1 对b的幂证明主定理
//   引理4.2 令a>=1.b>1是常数，f(n)是一个定义在b的幂上的非负函数。T(n)是定义在b的幂上的递归式：
//           T(n) = theta(1)        n=1
//                = aT(n/b) + f(n)  n=b的i次方(i为正整数)
//           T(n) = theta(n的logb(a)次方) + 求和(0 to logb(n-1))(a的j次方)f(n/(b的j次方))  (使用递归树求总代价)
//   从递归树看，主定理三种情况对应：
//       1 树的总代价由叶结点的代价决定
//       2 树的总代价均匀分布在树的所有层上
//       3 树的总代价由根结点的代价决定
//   引理4.3 令a>=1.b>1是常数，f(n)是一个定义在b的幂上的非负函数。g(n)是定义在b的幂上的函数：
//           g(n) = 求和(0 to logb(n-1)) (a的j次方)f(n/(b的j次方))
//           对b的幂，g(n)有如下渐近界：
//              1 若对某个常数e>0有f(n) = O(n的(logb(a-e))),则g(n) = O(n的logb(a)次方)
//              2 若f(n) = theta(n的logb(a)次方),则g(n) = theta(n的logb(a)次方lgn)
//              3 若对某个常数c<1和足够大的n有af(n/b) <= cf(n),则g(n) = theta(f(n))
//   引理4.4 利用4.3的界和4.2的和式进行求值。
//           1 T(n) = theta(n的logb(a)次方) + O(n的logb(a)次方)        = theta(n的logb(a)次方)
//           2 T(n) = theta(n的logb(a)次方) + theta(n的logb(a)次方lgn) = theta(n的logb(a)次方lgn)
//           3 T(n) = theta(n的logb(a)次方) + theta(f(n))              = theta(f(n))

// 4.6.2 向下取整和向上取整
//   通过向下或向上取整，将递归式定义在所有整数上。
//   上下界证明类似，以上界证明为例。
//   nj(表示序列中第j个元素) = n        j=1
//                           = [Nj-1/b] j>0
//   nj <= n/b的j次方 + 求和(0 to j-1)(1/b的i次方) < n/b的j次方 + 求和(0 to 无穷)(1/b的i次方) = n/b的j次方 + b/(b-1)
//   令j=[logb(n)], nj < b + b/(b-1) = O(1)
//   T(n) = theta(n的logb(a)次方) + 求和(0 to [logb(n)]-1)(a的j次方)f(nj)
//   f(nj) <= c(n/b的j次方 + b/(b-1))的logb(a)次方 <= O(n的logb(a)次方/a的j次方)


// test 
// 1 对b是正整数而非任意实数的情况，给出公式(4.27)中nj的简单而准确的表达式
//   nj = [N/b的j次方]

// 2 Show that if f(n) = theta(n的logb(⁡a)次方(lgn)次方), where k≥0k≥0, then the master recurrence has solution T(n)=theta(n的logb(a)次方(lgn)的k次方).
//   For simplicity, confine your analysis to exact powers of b.
//   g(n) = 求和(0 to logb(n-1)) (a的j次方f(n/b的j次方))
//   代入f(n) = theta(n的logb(⁡a)次方(lgn)次方)
//   g(n) = theta(求和(0 to logb(n-1)) a的j次方 x (n/b的j次方)的logb(⁡a)次方 x (lg(n/b的j次方))次方)
//        = n的logb(a)次方 x 求和(0 to logb(n-1)) (a/(b的logb(a)))的j次方 x (lg(n/b的j次方))次方)
//        = n的logb(a)次方 x 求和(0 to logb(n-1))(lg(n/b的j次方))次方)
//        = n的logb(a)次方 x 求和(0 to logb(n-1))((lgn)的k次方 - o((lgn)的k次方)
//        = n的logb(a)次方 x (logb(n)(lgn)的k次方 + logb(n) x o((lgn)的k次方)
//        = n的logb(a)次方 x theta(logb(n) x (lgn)的k次方)
//        = theta(n的logb(a)次方 x (lgn)的k+1次方)
//   T(n) = theta(n的logb(a)次方) + g(n) 
//        = theta(n的logb(a)次方) + theta(n的logb(a)次方 x (lgn)的k+1次方)
//        = theta(n的logb(a)次方 x (lgn)的k+1次方) 即证

// 3 证明主定理情况3被过分强调了，某种意义上，对某个常数c<1,正则条件af(n/b)<=cf(n)成立本身意味着存在常数e>0,使得f(n) = Omiga(n的logb(a+e)次方)
//   令A = a/c
//   af(n/b) <= cf(n) 等价为 Af(n/b) <= f(n)
//   Af(n) <= f(nb)
//   A的i次方f(n) <= f(n(b的i次方))
//   A的i次方f(1) <= f(b的i次方)
//   令n = b的i次方，i = logb(n),则
//   f(n) = A的logb(n)次方 x f(1) = Omiga(n的logb(A))  (A>a 等价于 A=a+d when c<1,d>0)
//   等价于 f(n) = n的(logb(a) + logb(d))次方 = n的logb(a+e)次方 (when e=logb(d))


// hard test
// 1 给出每个递归式的渐近上下界，并验证。假定n<=2时，T(n)是常数。
// a T(n) = 2T(n/2) + nnnn
//   a=2,b=2,n的logb(a)次方=n < f(n)=nnnn
//   T(n) = theta(nnnn)
//   Prove: T(n) <= cnnnn
//   T(n) = 2T(n/2) + nnnn
//       <= 2c(n/2)的4次方 + nnnn
//        = (c/8+1)nnnn
// b T(n) = T(7n/10) + n
//   a=1,b=7,n的logb(a)次方=1 < f(n)=n
//   T(n) = theta(n)
//   Prove: T(n) <= cn
//   T(n) = T(7n/10) + n
//       <= c(7n/10) + n
//        = (7c/10 + 1)n
// c T(n) = 16T(n/4) + nn
//   a=16,b=4,n的logb(a)次方=nn = f(n)=nn
//   T(n) = theta(nnlgn)
//   Prove: T(n) <= cnnlgn
//   T(n) = 16T(n/4) + nn
//       <= 16c(n/4)的平方lg(n/4) + nn
//        = cnnlgn +  (1-2c)nn
//       <= cnnlgn  (when c >= 1/2)
// d T(n) = 7T(n/3) + nn
//   a=7,b=3,n的logb(a)次方 < f(n)=nn
//   T(n) = theta(nn)
//   Prove: T(n) <= cnn
//   T(n) = 7(n/3) + nn
//       <= c7(n/3)的平方 + nn
//        = (7c/9 + 1)nn
// e T(n) = 7T(n/2) + nn
//   a=7,b=2,n的logb(a)次方 > f(n)=nn
//   T(n) = theta(n的log2(7)次方)
//   Prove: T(n) <= cn的log2(7)次方 - dnn
//   T(n) = 7T(n/2) + nn
//       <= 7c(n/2)的log2(7)次方 -d(n/2)的平方 + nn
//        = cn的log2(7)次方 + (1 - d/4)nn
//       <= cn的log2(7)次方 (when d >= 4)
// f T(n) = 2T(n/4) + 根号n
//   a=2,b=4,n的logb(a)次方=根号n = f(n)
//   T(n) = theta((根号n)lgn)
//   Prove: T(n) <= c(根号n)lgn
//   T(n) = 2T(n/4) + 根号n
//       <= 2c(根号n/4)lg(n/4) + 根号n
//        = c(根号n)lgn + (1 - 2c)(根号n)
//       <= c(根号n)lgn (when c >= 1/2)
// g T(n) = T(n-2) + nn
//   不适用主方法，采用递归树法。
//   T(n) = nn + (n-2)的平方 + (n-4)的平方 +...+ T(2)
//        = 求和(0 to n/2 - 1)(n - 2i)的平方 + T(2)
//        = theta(nnn)

// 2 参数传递的代价
//  1 数组通过指针传递，时间=theta(1)
//  2 数组通过元素复制来传递，时间=theta(N) (N为数组规模)
//  3 传递数组时，只复制过程可能访问的子区域，时间=theta(q-p+1) (子区间长度)
// a 采用递归二分查找法，求三种情况下最坏运行时间的递归式，并给出解的上界。
//   1 T(n) = T(n/2) + c =theta(lgn)
//   2 T(n) = T(n/2) + cN = T(n/4) + 2cN =...= 求和(0 to lgn-1)(2的i次方cN) = cNlgn =theta(nlgn)
//   3 T(n) = T(n/2) + cn = theta(n)
// b 采用归并排序
//   1 T(n) = 2T(n/2) + cn = theta(nlgn)
//   2 T(n) = 2T(n/2) + cn + 2N 
//          = 求和(0 to lgn-1)(cn + 2的i次方N) 
//          = cnlgn + N((2的lgn次方-1)/(2-1))
//          = cnlgn + nN - N
//          = theta(nn)
//   3 T(n) = 2T(n/2) + cn + 2n/2
//          = 2T(n/2) + (c+1)n
//          = theta(nlgn)

// 3 给出每个递归式的渐近上下界，并验证。假定对足够小的n，T(n)是常数。
//  1 T(n) = 4T(n/3) + nlgn
//    a=4,b=3,n的logb(a)次方=n的log3(4)次方=n(n的log3(4/3)次方) > nn > f(n)=nlgn
//    T(n) = theta(n的log3(4)次方)
//  2 T(n) = 3T(n/3) + n/lgn
//    a=3,b=3,n的logb(a)次方=n   f(n)=n/lgn
//    when n>=2  n的logb(a)次方 >= f(n)   so T(n) = theta(n)
//    or 积分求和的近似
//    T(n) = 3T(n/3) + n/lgn = ntheta(1) + 求和(0 to log3(n-1)) (n/(lg n-1))
//         = theta(n) + 求和(1 + lgn - log3(n)) (1/i)
//         = theta(nlglgn)
//  3 T(n) = 4T(n/2) + nn根号n
//    a=4,b=2,n的logb(a)次方=nn < f(n)
//    T(n) = theta(nn根号n)
//  4 T(n) = 3T(n/3 - 2) + n/2
//    n足够大时，忽略-2. a=3,b=3,n的logb(a)次方n = f(n)
//    T(n) = theta(nlgn)
//  5 T(n) = 2T(n/2) + n/lgn
//    积分求和近似
//    T(n) = 2T(n/2) + n/lgn
//         = theta(n) + 求和(0 to lg n-1) (n/(lgn - i))
//         = theta(nlglgn)
//  6 T(n) = T(n/2) + T(n/4) + T(n/8) + n
//    类4.4-6，从log8(n)开始不完全，每层代价为cn，层高为lgn
//    T(n) >= O(nlgn)
//  7 T(n) = T(n-1) + 1/n
//    积分求和近似
//    T(n) = T(n-1) + 1/n
//         = 1/n + 1/(n-1) + T(n-2)
//         = 求和(0 to n-1) (1/(n-i)) + theta(1)
//         = theta(lgn)
//  8 T(n) = T(n-1) + lgn
//    递归树
//    T(n) = 求和(0 to n-1)(lg n-i)
//         = 求和(1 to n) (lgi) + theta(1)
//         = theta(lg(n!))
//        <= theta(nlgn)
//  9 T(n) = T(n-2) + 1/lgn
//    积分求和的近似
//    T(n) = 1/lgn + 1/lg(n-2) +...+ theta(1)
//         = 求和(0 to n/2 - 1)(1/lg(n-2i))
//         = 求和(2 to n)(1/lgi)
//         = 求和(1 to lgn)(1/i)
//         = theta(lglgn)
//  10 T(n) = 根号nT(根号n) + n
//     换元法 + 主定理
//     令S(n) = T(n)/n,则S(n) = S(根号n) + 1
//     考虑n=2的m次方时，有S(2的m次方) = S(2的m/2次方) + 1
//     令P(m) = S(2的m次方),则P(m) = P(m/2) + 1
//     a=1,b=2,n的logb(a)次方=1 = f(n)
//     P(m) = theta(lgm)
//     T(n) = nS(n) = nP(m) = theta(nlgm) = theta(nlglgn)

// 4 Fibonacci numbers (Fi = Fi-1 + Fi-2)
//   讨论递归式定义的斐波那契数的性质。使用生成函数技术求解斐波那契递归式。
//   生成函数(形式幂级数F) F(z) = 求和(0 to 无穷)(Fi(z的i次方))
//   a Prove:F(z) = z + zF(z) + zzF(z)
//     F(z) = z + z求和(0 to 无穷)(Fi(z的i次方)) + zz求和(0 to 无穷)(Fi(z的i次方))
//          = z + 求和(1 to 无穷)(Fi-1(z的i次方)) + 求和(2 to 无穷)(Fi-2(z的i次方))
//          = z + 求和(2 to 无穷)((Fi-1 + Fi-2)(z的i次方))
//          = z + 求和(2 to 无穷)(Fi(z的i次方))
//          = F(z)
//   b Prove: F(z) = z/(1-z-zz) = z/(1-fz)(1-f'z) = 1/根号5(1/(1-fz) - 1/(1-f'z))
//     f = (1+根号5)/2  f' = (1 - 根号5)/2
//     From a: F(z) = z/(1-z-zz)
//   c Prove: F(z) = 求和(0 to 无穷)(1/根号5(f的i次方 - f'的i次方)(z的i次方))
//     由几何级数性质1/(1-x) = 求和(0 to 无穷)(x的k次方) (when -1<x<1)
//     F(z) = 1/根号5(1/(1-fz) - 1/(1-f'z))
//          = 1/根号5(求和(0 to 无穷)((f的i次方)(z的i次方)) - 求和(0 to 无穷)((f'的i次方)(z的i次方)))
//          = 求和(0 to 无穷)(1/根号5(f的i次方 - f'的i次方)(z的i次方))
//   d Prove: 对i>0, Fi = f的i次方/根号5，结果舍入到最接近的整数。
//     Fi = f的i次方/根号5 - f'的i次方/根号5
//     Fi = {0，1，2，3，5，8，13，......}
//     当i>0 , -1<f'<1时， -0.5<f'的i次方/根号5<0.5
//     所以，对一个整数，加减一个小于0.5的数，对所得结果舍入到最近整数即可。

// 5 芯片检测。 有n片可能完全一样的芯片，可以相互检测。一次只能装两块，两块互测，好芯片能准确报告，坏芯片不能。
//   可能结果：1代表好，0代表坏
//    11 - 都好或都坏  10 - 至少一个坏  01 - 至少一个坏  00 - 至少一个坏
//  a 如果超过n/2块坏芯片，任何逐对检测都无法确定芯片好坏。
//    当好芯片数量少于n/2时，会有同样数量或更多的坏芯片，无法判断准确性。
//    当好芯片数量多余n/2时，准确判断的结果多于不准确的，因此报告结果最多的即为准确结果。
//  b 考虑从n块芯片中找一块好芯片，假设有超过n/2块好芯片。证明：进行[n/2]次逐对检测足以将问题规模减半。
//    分两类，每类[n/2]个，逐对比较，保留情况1的（也就是至少剔除一个坏的）。剩下的每对芯片随机留一个，组成新集合。
//    该集合满足：超过一半的好芯片，同时规模减半。
//  c 求b对应的递归式及对应的解。
//    T(n) = T(n/2) + [n/2]
//    T(n) = theta(n)

// 6 Monge阵列  对一个mxn实数阵列A，若对所有满足1<=i<k<=m和1<=j<l<=n的i,j,k,l有：
//   A[i,j] + A[k,l] <= A[i,l] + A[k,j],则称为Monge阵列。
//   换言之，无论何时选出Monge阵列的两行或两列，对于交叉点上的4个元素，左上和右下之和总小于左下和右上之和。
// a 证明：一个数组是Monge阵列当且仅当对所有i=1,2...,m-1和j=1,2...n-1，有A[i,j] + A[i+1,j+1] <= A[i,j+1] + A[i+1,j]
//   假设    A[i,j] + A[k,j+1] <= A[i,j+1] + A[k,j]
//   递归    A[k,j] + A[k+1,j+1] <= A[k,j+1] + A[k+1,j]
//   相加得  A[i,j] + A[k,j+1] + A[k,j] + A[k+1,j+1] <= A[i,j+1] + A[k,j] + A[k,j+1] + A[k+1,j]
//   两边同时消去A[k,j+1] + A[k,j] 得A[i,j] + A[k+1,j+1] <= A[i,j+1] + A[k+1,j]
//   同理得证列
// b 下列数组不是Monge阵列。改变一个元素使之变成Monge阵列
//    37 23 22 32
//    21  6  7 10
//    53 34 30 31
//    32 13  9  6
//    43 21 15  8
//   将第一行第三列22改为24.
// c 令f(i)表示第i行最左最小元素的列下标。证明：对任意mxn的Monge阵列，f(1)<=f(2)<=...f(m)
//   反证法。 若f(i) > f(j) (i<j)
//   A[i,f(i)] + A[j,f(j)] < A[i,f(j)] + A[j,f(i)]
//   与A[i,f(j)] + A[j,f(i)] <= A[i,f(i)] + A[j,f(j)]矛盾
// d 计算mxn的Monge阵列A每一行最左最小元素的分治算法的描述：
//     提取A的偶数行构造子矩阵A'。递归确定A'每行的最左最小元素。然后计算A的奇数行的最左最小元素。
//   解释如何在O(m+n)时间内计算A的奇数行的最左最小元素（在偶数行的最左最小元素已知的情况下）
//   T(m,n) = 求和(0 to m/2 - 1)(u2i+2 - u2i + 1)
//          = 求和(0 to m/2 - 1)(u2i+2) - 求和(0 to m/2 - 1)(u2i) + m/2
//          = 求和(1 to m/2)(u2i) - 求和(0 to m/2 - 1)(u2i) +m/2
//          = um - u0 + m/2
//         <= n + m/2
//          = O(m+n)
// e 给出d中算法的递归式，求解。
//   T(m) = T(m/2) + cn + m/2
//        = cn + dm/2 + cn + dm/4 +...
//        = 求和(0 to lg m-1)(cn) + 求和(0 to lgm)(dm/(2的i+1次方))
//        = cnlgm + dm求和(0 to lg m-1)(1/2的i+1次方)
//        < cnlgm + dm求和(0 to 无穷)(1/2的i次方)
//        = cnlgm + 2dm
//        = O(nlgm + m)


// 概率分析和随机算法
// 5.1 雇佣问题
//   需要雇佣一名新的办公助理。雇佣代理每天推荐一个应聘者。
//   给雇佣代理一小笔费用用于推荐，如果雇佣需要一大笔钱且辞掉目前办公助理。
//   任何时候都需要有在职的办公助理，如果发现更合适的，则辞掉目前的聘用新的。
//   采取该策略，估算费用是多少。
//   假设应聘候选人编号1-n。过程中，面试完i后，决定i是否是目前见过的最佳人选。初始化时，虚拟应聘者0，他是所有人里最差的。
//  伪代码：
//  Hire_Assistant(n)
//   best = 0
//   for i=1 to n
//     interview candidate i
//     if candidate i is better than candidate best
//        best = i
//        hire candidate i
//     该模型与第二章不同，不关注执行时间，而关注面试和雇佣产生的费用。但都是计算特定基本操作的执行次数。
//     面试费用较低，记为ci；雇佣费用较高记为ch。假设雇佣人数为m，则算法总费用为O(cin + chm)
//     由于需要面试所有人，即总是花费cin，所有关注于分析chm
//   这个场景用作一般计算范式的模型。通常通过检查序列中每个成员，维护一个当前的best，来找出序列中的最值。这个问题对当前best的更新频率建立模型。

// 5.1.1 最坏情形分析
//   应聘者质量按出现次序严格递增，雇佣了n次，总费用为O(chn)
//   但应聘者质量并非总以递增次序出现。事实上也无法知道出现次序，无法控制次序。
//   因此会想在一种典型或平均情形下，会有什么发生。

// 5.1.2 概率分析
//   在问题分析中应用概率的理念。 
//   大多数情况下，运用概率分析来分析算法运行时间或分析其他量（如费用）
//   为了概率分析，需要使用或假设关于输入的分布，计算出平均情形下的运行时间。对所有可能输入产生的时间取平均，即平均情况运行时间。
//   在确定输入分布时必须非常小心，需要确定一个合理的输入分布，在此基础上设计算法。如果输入分布不合理，则不能采用概率分析。
//   雇佣问题中，假设应聘者随机出现，应聘者存在全序关系。因此，对应聘者用唯一号码排列名次，排名构成一个均匀随机排列，每种等概率出现。

// 5.1.3 随机算法
//   许多情况下，对输入分布的了解很少。即使知道输入分布的部分信息，也难以建立计算模型。
//   通过算法部分行为随机化，可以利用概率和随机性作为算法设计和分析的工具。
//   如果一个算法的行为不仅由输入决定，也由随机数生成器产生的数值决定，则称该算法是一个随机算法。
//   随机数生成器RANDOM(a,b)返回一个介于ab之间的数，等可能出现。(实践中，编程环境提供一个伪随机数生成器，是一个确定性算法，返回值在统计上看起来是随机的)
//   在分析一个随机算法时，以运行时间的期望值衡量(期望运行时间)


// test
// 1 证明：假设在过程Hire_Assistant的第4行中，总能决定哪一个应聘者最佳，则意味着我们知道应聘者排名的全部次序。
//   1 由于总能决定那个应聘者最佳，故两两之间都定义了关系，所以是一个全关系
//   2 其次由于1、每个应聘者都比自己好或者更好，所以满足自反性；
//             2、如果应聘者A比B好或更好，B又比A好或更好，而且因为总能决定哪个应聘者最佳，故显然没有两个同样好的不同应聘者，那么显然A就是B，所以满足反对称性；
//             3、如果应聘者A比B好，B又比C好，那么显然A就比C好，所以满足传递性。因此该关系就是一个偏序关系。
//   3 由于该关系同时是全关系和偏序关系，所以就是一个全序关系，所以我们能知道应聘者的全部次序。

// 2 描述Random(a,b)过程的一种实现，只调用Random(0,1).
//   伪代码：
//   Random(a,b)
//   do
//     取n为log(b-a)的向上取整
//      x = 0
//      for i=0 to n-1
//          x += pow(2,i) * Random(0,1)
//    while (x <= b-a)  
//    return x+a

// 3 以1/2的概率输出0与1.使用输出0或1的过程Biased_Random.
//   以概率p输出1，概率1-p输出0，0<p<1.
//   给出一个算法，返回一个无偏的结果，能以1/2概率输出1.
//   伪代码：
//   Biased_Random(p)
//    x = p
//    while x isn't integer  //p小数点右移等到整数x
//          x *= 10t
//    total = x/p   // 将p扩大到x一共扩大了total倍
//    if Random(0,total) <= x  // total个数中，调用Random(0,total)返回值小于x，返回1
//       return 1
//    else
//       return 0
//    NonBiased_Random(0,1)
// 1   x = 0
// 2   for i=0 to 1
// 3       x += pow(x,i) * Biased_Random(0,1)  // pow(x,y)=x的y次幂
 //    if x==1
//        return 0
//     else if x==2
//        return 1
//     else
//        circle step 1 to 3

// 5.2 指示器随机变量
//   为了分析雇佣问题在内的许多算法，采用指示器随机变量，为概率与期望之间的转换提供一个便利方法。
//   给定一个样本空间S和一个事件A，A对应的指示器变量I{A}定义为：
//       I{A} = 1 (when A happen)
//            = 0 (when A didn't happen)
// 5.2.1 引理5.1 
//   给定一个样本空间S和S中的一个事件A，设XA=I{A}，那么E[XA]=Pr{A}.
//   Prove: E[XA] = E[I{A}] = 1xPr{A} + 0xPr{A~} = Pr{A}
//   期望的线性性质利用指示器随机变量作为一种强大的分析技术；当随机变量之间存在依赖关系时也成立。
//   相比和等式(C.37)，指示器随机变量极大简化计算过程。

// 5.2.2 用指示器变量分析雇佣问题
//   假设应聘者以随机顺序出现。设X是一个随机变量，值等于我们雇佣一个新办公助理的次数。
//   应用期望定义，E[X] = 求和(x=1 to n)xPr{X=x} (但是这样计算麻烦)
//   为了利用指示器随机变量，通过定义n个变量，与每个应聘者是否被雇佣对应。
//   假设Xi对应于第i个应聘者被雇佣该事件的指示器随机变量，
//       Xi = I{应聘者i被雇佣} = 1 如果i被雇佣
//                             = 0 如果i不被雇佣
//       X = 求和(i=1 to n) (Xi)
//       E[Xi] = Pr{应聘者i被雇佣}
//   前i个应聘者中任意一个都等可能地是目前最有资格的。应聘者i比应聘者1到i-1更有资格的概率是1/i，被雇佣的概率为1/i
//       E[Xi] = 1/i
//       E[X] = E[求和(i=1 to n) (Xi)] = 求和(i=1 to n)E[Xi] = lnn + O(1)  
//   尽管面试了n个人，平均下来只雇佣了其中的lnn个人。

// 5.2.3 引理5.2
//   假设应聘者以随机次序出现，算法Hire_Assistant总的雇佣费用平均情形下为O(Chlnn)
//   由上述等式证得。


// test
// 1 Hire_Assistant中，雇佣一次的概率为，雇佣n次的概率为？
//   A雇佣一次：最佳者出现在第一次面试 Pr{A}=1/n
//   B雇佣n次： 面试者出现顺序按递增排序（唯一），共有n!种排列可能 Pr{B}=1/n!

// 3 利用指示器随机变量来计算掷n个骰子之和的期望值
//   扔一个骰子E(x) = 1*1/6 + 2*1/6 + 3*1/6 + 4*1/6 + 5*1/6 + 6*1/6 = 3.5
//   扔n个骰子 E(nx) = nE(x) = 3.5n

// 4 帽子核对问题：n位顾客，他们每个人给餐厅核对帽子的服务生一顶帽子。服务生随机顺序将帽子归还给顾客。拿回自己帽子的客户的期望数。
//   第一位顾客：E(X1) = 1/n
//   第二位顾客：E(X2) = (n-1)/n (帽子没被拿错的概率) * (1/(n-1)) (拿到自己帽子的概率) = 1/n
//   ...
//   第n位顾客： E(Xn) = 1/n
//   E(X) = E(X1) + E(X2) +...+ E(Xn) = 1

// 5 设A[1...n]是由n个不同的数构成数组。如果i<j且A[i]>A[j],则称(i,j)对为A的一个逆序对
//   假设A的元素构成<1,2,...,n>上的一个均匀随机排列。请用指示器随机变量来计算其中逆序对的数目期望。
//   n个元素有Cn(2)种选择方法，两个元素要么顺序要么逆序，可能性为1/2.
//   E(X) = E(X1)+E(X2)+...+E(Xn)=(1/2)Cn(2) = (n-1)n/4

// 5.3 随机算法
//   对于如雇佣问题，假设输入的所有排列等可能出现比较有益，通过概率分析可以指导设计一个随机算法。
//   不是假设输入的一个分布，而是设定一个分布。
//   在算法运行前，随机排列应聘者。
//   概率分析中，聘用一个新办公助理的期望次数是lnn；随机算法中，用应聘者有序排名列表来代表特定输入对应一个固定的输出，算法费用依赖输入。
//   先考虑对应聘者排列，在确定最佳应聘者的随机算法。让随机发生在算法上而不是输入分布上。
//   对于雇佣问题，代码中唯一改变的是随机变换应聘者序列
//   Randomized_Hire_Assistant(n)
//    randomly permute the list of candidates
//    best = 0
//    for i=1 to n
//        interview candidate i
//        if candidate i is better than candidate best
//           best = i
//           hire candidate i
// 5.3.1 引理5.3 过程Randomized_Hire_Assistant的雇佣费用期望是O(Chlhn)
//   Prove:对输入数组进行变换后，已经达到和Hire_Assistant概率分析时相同的情况。
//   引理5.2中，在输入上做出假设；引理5.3中没有做这种假设，但在随机化输入上会花费额外时间。
//   用平均情形下的雇佣费用来表达引理5.2，用期望雇佣费用来表达引理5.3.

// 5.3.2 随机排列数组
//   很多随机算法通过对给定输入变换排列使输入随机化(当然也有其他方法)
//   此处讨论两种随机化方法。假设给定一个数组A，包含元素1到n。通过该数组构造一个随机排列。
//   为每个数组元素A[i]赋一个随机优先级P[i],然后依据优先级对数组A种元素进行排序。
//     例如：对初始数组A=<1,2,3,4>,随机优先级P=<36,3,62,19>,产生数组B=<2,4,1,3>
//     称此过程为Permute_By_Sorting
//   Permute_By_Sorting:
// 1   n = A.length
// 2   let P[1...n] be a new array
// 3   for i=1 to n
// 4       P[i] = Random(1,nnn)
// 5   sort A,using P as sort keys
//   在第四行选取一个1到nnn之间的随机数（该范围为了使P中优先级尽可能唯一）
//   第五行耗时最多。如果使用比较排序将花费theta(nlgn)时间。如果P[i]是第j个最小优先级，它将出现在输出的j位置上。

// 5.3.2 引理5.4 假设所有优先级都不同，则过程Permute_By_Sorting产生输入的均匀随机排列。
//   Prove:考虑每个元素A[i]分配到第i个最小优先级的特殊排列开始，并说明这个排列正好发生的概率是1/n!
//         对i=1,2,...,n,设Ei代表元素A[i]分配到第i个最小优先级的事件。
//         计算对所有i，事件Ei发生的概率：Pr{E1∩E2∩...∩En-1∩En}
//         由C.2-5得：上式 = Pr{E1}*Pr{E2|E1}*Pr{E3|E2∩E1}*...*Pr{Ei|Ei-1∩Ei-2∩...∩E1}*...*Pr{En|En-1∩En-2∩...∩E1}
//         Pr{E1}代表从n个元素中随机选择最小优先级的概率，为1/n
//         Pr{E2|E1} = 1/(n-1)
//         ...
//         Pr{Ei|Ei-1∩Ei-2∩...∩E1} = 1/(n-i)
//         ...
//         Pr{En|En-1∩En-2∩...∩E1} = 1
//         所以 Pr{E1∩E2∩...∩En-1∩En} = 1/n * 1/(n-1) * ... * 1/2 * 1 = 1/(n!)
//         同理 获得任意特定排列的概率为1/(n!)

// 5.3.3 更好的算法以产生随机排列
//   要证明一个排列是均匀随机排列，即证每个元素出现在位置j的概率是1/n。但实际上这个若条件不充分。
//   产生随机排列的一个更好的算法是原址排列给定数组。过程Ranmoized_In_Place在O(n)内完成。在进行i次迭代时元素A[i]是从元素A[i]到A[n]随机选取的。i次后，A[i]不变。
//   Randomized_In_Place(A)
// 1  n = A.length
// 2  for i=1 to n
// 3      swap A[i] with A[Random(i,n)]
//   将使用循环不变式来证明过程能产生一个随机均匀排列，一个具有n个元素的k排列(k-permutation)是包含这n个元素中的k个元素的序列，并且不重复。一共有n!/(n-k)!种可能的k排列

// 5.3.4 引理5.5 过程Randomized_In_Place可计算出一个均匀随机排列
//   Prove:在第2-3行for循环的第i次迭代之前，对每个可能的(i-1)排列子数组A[1...i-1]包含这个(i-1)排列的概率是(n-i+1)!/n!
//         初始化：在第一次循环迭代时，i=1.对每个可排列的0排列，子数组A[1...0]包含这个0排列的概率是(n-i+1)!/n! = n!/n! = 1.子数组为空数组，无元素不需要排列，成立。
//         保持：假设在第i次迭代之前，对每种可能的(i-1)排列子数组A[1...i-1]包含这个(i-1)排列的概率是(n-i+1)!/n!。
//               在第i次迭代之后，对每种可能的i排列子数组A[1...i]包含这个i排列的概率是(n-i)!/n!
//               记Pr{E1} = (n-1+1)!/n!  E2表示第i次迭代在位置A[i放置xi的事件。
//               E1，E2恰好发生时，i排列<x1,...,xi>出现在A[1...i]中，计算Pr{E2∩E1} = Pr{E2|E1}*Pr{E1} = 1/(n-i+1) * (n-1+1)!/n! = (n-1)!/n! 成立
//         终止：终止时，i=n+1,子数组A[1...n]是一个给定n排列的概率为(n-(n+1)+1)/n! = 0!/n! = 1/n!
//         因此，Randomized_In_Place产生一个均匀随机排列。
//  一个随机算法通常是解决一个问题最简单、最有效的方法。

// test 
// 1 重写Randomize_In_Place,使得相关循环不变式适用于第一次迭代之前的非空子数组，并修改引理5.5的证明。
//   将数组A的第一个元素的随机交换单独列出
//   循环从数组A的第二个元素开始直至最后
//   Randomize_In_Place(A)
//     n = A.length
//     swap A[1] with A[Random(1,n)]
//     for i=2 to n
//         swap A[i] with A[Random(i,n)]
//   证明修改：
//     初始化：此时i=2。对每个可能的1排列，子数组A[1]包含这个1排列的概率：
//               (n-i+1)!/(n-1)! = (n-2+1)!/(n-1)! = 1
//             子数组A[1]是一个单元素数组，1排列也是单元素排列，因此任意1排列概率为1.成立。

// 2 Kelp教授写了一个过程来随机产生除恒等排列(identity permutation)外的任意排列
//   附：排列恒等式的定义：含有排列数的恒等式。 
//   伪代码如下：
//   Permute_Without_Identity(A):
//   1 n = A.length
//   2 for i=1 to n-1
//   3     swap A[i] with A[Random(i+1,n)]
//   能实现目的吗？ (经过随机排列之后，任意一共非恒等排列出现的概率均为1/(n!-1))
//     不能。 理由如下：
//     假设第i次循环之后，对于任意非恒等子排列出现在前i位的概率为1/(An(i) - 1)
//     如果假设成立，迭代到i=n-1时，目的实现，如果不成立，此时i对应的n即为反例。
//     设事件E1表示i次循环后，对于任意特定非恒等子排列，该排列的前i-1位出现数列的前i-1位；
//     设事件E2表示该特定非恒等子排列的第i位出现在数列第i位置。
//     当且仅当E1，E2同时发生的时候该特定顺序的前i位出现在数列的前i位。
//     该事件概率为P(E1∩E2) = P(E2|E1)*P(E1) = (n-i)/(n-i+1)*1/(n-i) = 1/(n-i+1)
//     又1/(n-i+1)*1/(An(i) - 1) != 1/(An(i) - 1) 不成立

// 3 假设不是将元素A[i]与子数组A[1...n]中的随机元素交换，而是将它与数组任何位置上的随机元素交换：
//   Permutation_With_All(A):
//   1 n = A.length
//   2 for i=1 to n
//   3     swap A[i] with A[Random(1,n)]
//   该代码会产生一个均匀随机排列吗？为什么会或为什么不会？
//   该代码能产生A中元素的全排列，但是可能出现相同的，如果重复次数相同就能产生均匀随机排列。
//   产生n的n次方个序列，而全排列只有n！个，n>2时不可能出现均匀随机序列。

// 4 Armstrong教授建议用下面的过程产生一个均匀随机排列：
//   Permutation_By_Cyclic(A):
//   1 n = A.length
//   2 let B[1...n] be a new array
//   3 offset = Random(1,n)
//   4 for i=1 to n
//   5     dest = i +offset
//   6     if dest>n
//   7        dest = dest - n
//   8     B[dest] = A[i]
//   9 return B
//   B其实是将A中每个元素，随机右移，显然不能得到A的所有排列，所以不是均匀随机排列。

// 5 证明：在过程Permute_By_Sorting的数组P中，所以元素都唯一的概率至少是1 - 1/n
//   设事件Ei为生成第i个标号与之前所有标号都不同，每个标号都不同的高铝为：
//   P(E) = P(E1∩E2∩...∩En) = P(E1)*P(E2|E1)*P(E3|E3∩E2∩E1)*...*P(En|En-1∩...∩E1)
//        = 连乘(i=1 to n) (nnn - 1 + 1/nnn)
//       >= (nnn - n/nnn)的n-1次方 (对i>=1 nnn-i>nnn-n)
//   又1 - 1/n = (n-1)/n = (n-1)的3次方/nnn = (nnn - n/nnn)的n-1次方
//   so P(E) >= 1 - 1/n

// 6 解释如何实现算法Permute_By_Sorting,以处理两个或更多优先级相同的情形。
//   当出现优先级相同的情况时，标记优先级相同的元素，递归调用该算法直至没有优先级相同的元素存在。
//   设对长度为n的数组生成优先级后，有k个元素优先级重复。
//   显然这k个元素的每一个排列单独对应整个数组的q个排列，容易证明q=An(n-k)=n!/k!
//   在已经出现了k个元素优先级相同的情况下，该优先级数列所表达的排列正好是一个特定的排列的事件E=事件E1
//   优先级不同的n-k个元素的顺序恰好是该特定顺序中优先级不同元素对应的顺序为事件E2
//   P(E) = P(E1∩E2) = P(E2|E1)*P(E1)
//   P(E1) = k!/n! 若P(E)=1.n!,则P(E2|E1)=1/k!
//   正好要求k个相同优先级对应元素的每种可能的顺序均为1/k!

// 7 希望创建集合{1,2,...,n}的一个随机样本，即具有m个元素的集合S，其中0<=m<=n,使得每个m集合被等可能创建。
//   一种方法是对i=1,2,...,n。设A[i]=i,调用Randomize_In_Place(A),取前m个元素，过程会对Random调用n次。
//   如果n远大于m，能够创建一个随机样本，只对Random调用更少次数。
//   请说明下面递归过程返回{1,2,...,n}的一个随机m子集S，其中每个m子集等可能的，然而只对Random调用m次。
//   Randomize_Sample(m,n)
//   1 if m==0
//   2    return 空集
//   3 else S=Randomize_Sample(m-1,n-1)
//   4      i = Random(1,n)
//   5      if i∈S
//   6         S = S ∪ {n}
//   7      else 
//   8         S = S ∪ {i}
//   9         return S
//   使用循环不定式证明。 严格意义上集合不分顺序，但算法和集合元素的自然顺序便于将集合看做有序。 集合前i个元素意为{1,2,...,i}
//   假设对于任意的i∈[1,m]表示递归返回次序。 第i次递归返回前，已经选取出容量为i-1的子集是集合S的前n-m+i-1个元素组成的集合的任意一个容量为i-1的子集的概率相等，均为1/C(n-m+i-1)(i-1)
//   当i增加到m+1时，从集合前n个元素中选出任意一个容量为m的子集的概率为1/Cn(m).
//   i = 1时，空集包含空集的概率为1；i = 2时，第一个选出元素是S的前n-m+1个元素中的任意一个的概率为P=1/(n-m+1).
//   第i次递归返回假设仍然成立，现证明如下:
//     设事件E表示第i次递归返回后，返回的容量为i的子集合是S的前n-m+i元素构成的集合中的某一个特定组合。
//     该组合的前i-1个元素一定均小于n-m+i，即一定是前n-m+i-1元素构成的集合某个容量为i-1的子集。
//     设E1包含第i-1次递归返回的集合属于该特定集合。
//     设E2表示第i次递归添加的元素属于该特定集合。
//     设E2表示该特定集合最大的元素恰好是n-m+i。
//     事件E相当于E1，E2同时发生。
//         P(E) = P(E1∩E1) = P(E1|E2)P(E2)
//     无论E3是否发生，当E2发生时，该特定顺序集合第i次之前添加的元素一定小于n-m+i。这些元素构成的集合恰好是第i次递归返回的集合的概率为1/C(n-m+i-1)(i-1)
//         P(E1|E2E3) = 1/C(n-m+i-1)(i-1)
//         P(E1|E2E3~) = 1/C(n-m+i-1)(i-1)
//         P(E1|E2) = 1/C(n-m+i-1)(i-1)
//     由概率论公理得：P(E2) = P(E2∩E3) + P(E2∩E3~)
//                     P(E2) = P(E2|E3)P(E3) + P(E2|E3~)P(E3~)
//     P(E2|E3) = (i-1+1)/(n-m+i) = 1/(n-m+i)
//     P(E2|E3~) = i/(n-m+i)
//     由组合数学得：P(E3) = C(n-m+i-1)(i-1)/C(n-m+i)(i)
//                   P(E3~) = C(n-m+i-1)(i)/C(n-m+i)(i)
//     so P(E2) = i/(n-m+i)
//        P(E) = P(E1|E2)P(E2) = 1/C(n-m+i)(i) 成立


// 5.4 概率分析和指示器随机变量的进一步使用
// 5.4.1 生日悖论
//   一个屋子里人数必须达到多少，才能使其中两人生日相同的机会达到百分之50？
//   用整数对屋子里的人编号(1,2,...,k)。不考虑闰年，假设n=365天。
//   对i=1,2,...k，设bi表示编号为i的人的生日，其中1<=bi<=n.
//   假设生日均匀分布在一年的n天中，因此对i=1,2,...,k和r=1,2,...,n，Pr{bi=r} = 1/n
//   前提：两个人i和j的生日正好相同的概率依赖于生日的随机选择是否独立。 
//         假设生日是独立的，于是i和j生日都在同一日r的概率是：Pr{bi=r ∩ bj=r} = Pr{bi=r}*Pr{bj=r} = 1/nn
//         则生日在同一天的概率是：Pr{bi=bj} = 求和(r=1 to n) (Pr{bi=r ∩ bj=r}) = 求和(r=1 to n) (1/nn) = 1/n
//   用事件补的方法来考虑。至少两人生日相同的概率=1 - 所有人生日不同的概率。
//       k个人生日互不相同的事件为：Bk = ∩(i=1 to k) (Ai)  (Ai是指对所有j<i,i与j生日不同的事件)
//       Bk = Ak∩B(k-1)  得递归式：Pr{Bk} = Pr{Bk-1}*Pr{Ak|B(k-1)}  (对i，b1,b2,...,bk互不相同的概率 = b1,b2,...,b(k-1)互不相同的概率 * bk != bi的概率)
//       其中取Pr{B1} = Pr{A1} = 1
//       所以 Pr{Bk} = Pr{B(k-1)}*Pr{Ak|B(k-1)}
//                   = ....
//                   = Pr{B1}*Pr{A2|B1}*...*Pr{Ak|B(k-1)}
//                   = 1*(n-1/n)*(n-2/n)*...*(n-k+1/n)
//                  <= (e的(-1/n)次方)*(e的(-2/n)次方)*...*(e的(-(k-1)/n)次方)  (1+x <= e的x次方)
//                   = (e的(-求和(i=1 to k-1)(i/n))次方)
//                  <= 1/2  (when -k(k-1)/2n <= ln(1/2))
//       解方程得：k >= (1+根号(1+(8ln2)n))/2,k个生日两两不同的概率至多是1/2.
//       当n=365使，必有k>=23   因此，至少23个人在一间物资里，那么至少有两个人生日相同的概率至少是1/2.

// 5.4.1.2 采用指示器随机变量的一个分析
//   用指示器随机变量给出生日悖论的一个简单近似分析。
//   对屋子里k个人中的每一对(i,j),对1<=i<j<=k，定义指示器随机变量Xij:
//     Xij = I{i和j生日相同} = 1  如果i和j生日相同
//                             0  其他
//   E[Xij] = Pr{i和j生日相同} = 1/n
//   设X表示计数生日相同两人对数目的随机变量 X = 求和(i=1 to k)(求和(j=k+1 to k)(Xij))
//     两边取期望 E[X] = E[求和(i=1 to k)(求和(j=k+1 to k)(Xij))] = 求和(i=1 to k)(求和(j=k+1 to k)(E[Xij])) = k(k-1)/2n
//   当k(k-1)>=2n时，生日相同的两人对的期望数至少是1。因此屋子里至少有(根号2n)+1个人，可以期望至少有两人生日相同。
//   对于n=365，若k=28，生日相同两人对的期望值为28*27/2*365=1.0356
//   第一种分析利用概率，第二种分析利用指示器随机变量。两种方法准确数目不同，但是都渐近于theta(根号n)

// 5.4.2 球与箱子
//   把相同的球随机投到b个箱子里。每次投球独立，每个球等可能落在每一个箱子中（概率为1/b）。
//   因此投球过程是一组伯努利实验吗，每次成功概率是1/b，其中成功指球落入指定箱子中。（该模型利于分析散列，11章）
//   有多少球落在给定箱子中？落在给定箱子里的球数服从二项分布b(k;n,1/b)。如果投n个球，落在给定箱子的球数期望值是n/b
//   在平均意义下，必须投多少个球，才能在给定箱子里投中一个球。 易知，成功投球次数期望值是b
//   需要投多少次球，才能使每个箱子里至少一个球？ 一次投球落在空箱子称为一次命中，即为求为了获得b次命中，所需投球次数的期望n。
//   采用命中次数，可以把n次投球分为几个阶段。 第i个阶段包括从第i-1次命中到第i次命中之间的投球。
//     第1阶段包含一次投球，因为都是空箱，所以可以保证一次命中。
//     第i阶段的每一次投球，有i-1个箱子有球，b-i+1个空箱子。 因此，第i阶段每次投球，命中一次的概率是(b-i+1)/b
//     设ni表示第i阶段投球次数。 为得到b次命中所需投球次数为n=求和(i=1 to b)(ni),每个随机变量ni服从几何分布，成功概率为(b-i+1)/b
//       so E[ni] = b/(b-i+1)
//          E[n] = E[求和(i=1 to b)(ni)] = 求和(i=1 to b)(E[ni]) = 求和(i=1 to b)(b/(b-i+1)) = b求和(i=1 to b)(1/i) = b(lnb+O(1))
//   所以期望每个箱子里都有一个球，大约要投blnb次。这个问题也被称为礼券收集者问题（收集b种不同的礼券中的每一种，大约需要blnb张随机得到的礼券）

// 5.4.3 特征序列
//   假设抛一枚硬币n次，最长连续正面的序列的期望长度是多少？ theta(lgn)
//     抛一次正面的概率为1/2   设Aik为这样的事件：长度至少为k的正面序列开始于第i次抛掷(i,i+1,...i+k-1都为正面，长度为k)
//     所有k次抛掷都是正面的概率为： Pr{Aik} = 1/2的k次方
//       对于k=2[lgN],Pr{Ai,2[lgN]} = 1/(2的2[lgN]次方) <= 1/(2的2[lgN]) = 1/nn
//       因此起始位置i，长度至少为2[lgN]的一个正面序列概率很小。这种序列起始位置之多有n-2[lgN]+1个。
//       长度至少为2[lgN]的正面序列开始于任一位置的概率是： Pr{∪(i=1 to n-2[lgN]+1) Ai,2[lgN]} <= 求和(i=1 to n-2[lgN]+1)(1/nn) = 1/n (由布尔不等式得，并集概率至多为各个事件概率之和)
//     利用不等式给出最长特征序列的长度界。
//       对于j=0，1，2，...，n。令Lj表示最长连续正面的特征序列长度正好是j的事件，设最长特征序列长度为L。
//       由期望定义得: E[L] = 求和(i=0 to n)(jPr{Lj})  得到一个弱的界。 此外，求和(j=0 to n)(Pr{Lj}) = 1,所以求和(j=0 to 2[lgN]-1)(Pr{Lj}) <= 1
//       所以 E[L] = 求和(i=0 to n)(jPr{Lj})
//                 = 求和(j=0 to 2[lgN]-1)(jPr{Lj}) + 求和(j=2[lgN] to n)(jPr{Lj})
//                 < 求和(j=0 to 2[lgN]-1)(2[lgN])(Pr{Lj}) + 求和(j=2[lgN] to n)(nPr{Lj})
//                 = 2[lgN]求和(j=0 to 2[lgN]-1)(2[lgN])(Pr{Lj}) + n求和(j=2[lgN] to n)(Pr{Lj})
//                 < 2[lgN]*1 + n*(1/n) 
//                 = O(lgn)  得到长度上界
//       正面特征序列长度超过r[lgN]次抛掷的概率随着r减少而减小。 对r>=1,正面特征序列长度小于r[lgN]的概率至少是1 - 1/(n的r-1次方)
//       求补充下界：n次硬币抛掷中，最长正面序列的长度期望为Omiga(lgn).
//         把n次抛掷分为大约n/s个组，每组s次抛掷，对长度为s的特征序列。
//         如果选择s=[(lgn)/2],可以说明这些组中至少有一组可能全是正面，因而可能最长特征序列的长度至少是s=Omiga(lgn)
//         从位置i开始的都是正面的组的概率为：Pr{Ai,[(lgn)/2]} = 1/(2的[(lgn)/2]) <= 1/根号n
//         所以长度至少为[(lgn)/2]的正面特征序列不从位置i开始的概率至多为1 - 1/根号n.
//         既然[n/[(lgn)/2]]个组彼此互斥、独立的抛硬币构成，其中每个组都不是长度为[(lgn)/2]的特征序列的概率至多是：
//             (1 - 1/根号n)的[n/[(lgn)/2]]次方 <= (1 - 1/根号n)的n/([(lgn)/2]-1)次方 
//                                              <= (1 - 1/根号n)的2n/(lgn - 1)次方 
//                                              <= e的-(2n/(lgn - 1))/根号n次方
//                                               = O(1/n)
//         因此最长特征序列超过[(lgn)/2]的概率为：求和(j=[(lgn)/2] to n)(Pr{Lj}) >= 1 - O(1/n)
//         E(L) = 求和(j=0 to n)(jPr{Lj})
//              = 求和(j=0 to [(lgn)/2]-1)(jPr(Lj)) + 求和(j=[(lgn)/2] to n)(jPr{Lj})
//             >= 求和(j=0 to [(lgn)/2]-1)(0*Pr(Lj)) + 求和(j=[(lgn)/2] to n)([(lgn)/2]*Pr{Lj})
//              = [(lgn)/2]*(1 - O(1/n))
//              = Omiga(lgn)
//     也可以采用指示器随机变量来得到一个简单近似分析。
//       设Xik=I{Aik}表示对应于特征序列长度至少为k，开始于位置i的指示器随机变量。
//       定义X = 求和(i=1 to n-k+1)(Xik)
//       两边取期望并利用期望的线性性质: E[X] = E[求和(i=1 to n-k+1)(Xik)] = 求和(i=1 to n-k+1)(E[Xik]) = 求和(i=1 to n-k+1)(1/2的k次方) = (n-k+1)/2的k次方
//       通过代入不同k值，可以计算出长度为k的特征序列的数目期望。对于某个正常数c，有k=clgn
//       则E[X] = (n-clgn+1)/2的clgn次方 = (n-clgn+1)/n的c次方 = 1/n的c-1次方 - (clgn-1)/n的c次方 = theta(1/n的c-1次方)

// 5.4.4 在线雇佣问题
//   雇佣问题的变形。假设现在我们不希望面试所有的应聘者以找到最好的一个。也不希望不停地雇佣新人解雇旧人。
//   愿意雇佣接近最好的应聘者，只雇佣一次。但是必须遵守，每次面试后必须马上提供职位给应聘者，或者马上拒绝该应聘者。
//   如何在最小化面试次数和最大化雇佣应聘者之间取得平衡？
//   建模如下：面试一个应聘者之后，给每个人一个分数；令score(i)表示第i个应聘者的分数，并假设没有两个应聘者得到同样的分数。
//             在已看过j个应聘者后，知道这j个人中哪一个分数更高，但不知道剩下n-j个人中会不会有更高分数的应聘者。
//   采取策略：选择一个正整数k<n，面试然后拒绝前k个应聘者，再雇佣其后比前面的应聘者有更高分数的第一个应聘者。
//             如果最好的应聘者在前k个面试之中，那么雇佣第n个应聘者。
//   伪代码：
//   On_Line_Maximum(k,n)
//   1 bestscore = -无穷
//   2 for i=1 to k
//   3     if score(i) > bestscore
//   4        bestscore = score(i)
//   5 for i=k+1 to n
//   6     if score(i) > bestscore
//   7        return i
//   8 return n
//   对每个可能的k，我们希望确定能雇佣最好应聘者的概率，然后选择最佳的k值。暂时假定k是固定的。
//   设M(j)=max{score(i)}表示1 to j中最高分数。设S表示成功选择最好应聘者的事件，Si表示最好应聘者是第i个面试者时成功的事件。
//   既然不同Si不相交，有Pr{S} = 求和(i=1 to n)(Pr{Si})。同时，当最好应聘者是前k个应聘者中的一个时，不会成功，于是对i=1,2,...,k,有Pr{Si}=0
//   因此，Pr{S} = 求和(i=k+1 to n)(Pr{Si})
//   计算Pr{Si}。为了当第i个应聘者是最好时成功，两件事必须发生。
//   第一，最好应聘者必须在位置i，用事件Bi表示。第二，算法不能选择从k+1 to i-1中的任何一个应聘者，即score(k+1) to score(i-1)均小于M(k).
//   如果其中有大于M(k)的数，则将返回第一个大于M(k)的数的下标。用事件Oi表示从位置1 to i-1中没有任何应聘者入选的事件。事件Bi于Oi相互独立。
//   Oi仅依赖于位置1 to i-1中值的相对次序，Bi仅依赖于位置i的值是否大于所有其他位置的值。从位置1 to i-1的排序不影响位置i的值是否大于其他值，i的值也不影响前面的次序。
//   因而 Pr{Si} = 求和(i=k+1 to n)(Pr{Si}) = Pr{Bi∩Oi} = Pr{Bi}*Pr{Oi}
//   Pr{Bi} = 1/n，因为最大值等可能是n个位置中的任意一个。 若事件Oi要发生，从位置1 to i-1的最大值必须在前k个位置的一个，并且最大值等可能地在这i-1个位置中。
//   于是 Pr{Oi} = k/(i-1) , Pr{Si} = k/(n(i-1)) , Pr{S} = 求和(i=k+1 to n)(Pr{Si}) = 求和(i=k+1 to n)(k/(n(i-1))) = (k/n)*求和(i=k to n-1)(1/i)
//   用积分近似约束这个和数的上下界： 积分(k to n)(1/x)dx <= 求和(i=k to n-1)(1/i) <= 积分(k-1 to n-1)(1/x)dx
//   得到一个相当紧确的界             (k/n)(lnn - lnk)    <= 求和(i=k to n-1)(1/i) <= (k/n)(ln(n-1) - ln(k-1))
//   因为希望最大化成功的概率，所以关注如何选取k值使Pr{S}的下界最大化。(当然下界更容易最大化) 以k为变量对下界表达式求导，得：(1/n)(lnn - lnk -1) = 0
//   所以k = n/e时，概率下界最大化。因而，如果用k = n/e来实现策略，那么将以至少1/e的概率成功雇佣到最好的应聘者。

// test
// 1 一个屋子必须要多少人，才能让某人和你生日相同的概率至少为1/2？必须要多少人，才能让至少两个人生日为7月4日的概率大于1/2？
//   设事件E表示至少有一个人和我生日相同，事件E~表示没人生日与我相同，则Pr{E} = 1 - Pr{E~} > 1/2
//   设有n个人，任意一个生日与我不同的概率为364/365，则事件Pr{E~} = (364/365)的n次方
//   Pr{E} = 1 - Pr{E~} = 1 - (364/365)的n次方 > 1/2   n>=253  
//   设房间里k个人，没人生日在7.4的概率为P1 = (364/365)的k次方
//   一人生日在7.4的概率为P2 = Ck(1) * 1/365 * (364/365)的k-1次方 = k/365 * (364/365)的k-1次方
//   则至少两人生日为7.4的概率为Pr = 1 - P1 - P2 = 1 - (364-k)/365 * (364/365)的k-1次方 >= 1/2
//   所以 k >= 115

// 2 假设将球投入b个箱子里，直到某箱子里中有两个球。每次投掷都是独立的，并且每个球等可能落入任意箱子。投球次数期望为？
//   任意球，投入某个箱子的概率为1/b
//   前i-1(2<=i<=b+1)次投掷，球在不同箱子的概率为1 * b-1/b * ... * (b-i+1)/b
//   第i个球落入已有球的箱子的概率(i-1)/b
//   所以第i次达成条件的概率为: Pr{i} = (i-1)/b * 连乘(j=1 to i-1)((b-j)/b)
//   E(X) = 求和(j=2 to b+1)(i*Pr{i}) = theta(根号b)

// 3 在生日悖论的分析中，要求各人生日彼此独立是否很重要？这个问题和生日悖论有什么关系？
//   分析中选取两人一对分析是否生日为同一天，所以只需要两两独立即可。

// 4 一次聚会需要邀请多少人，才能让其中3个人生日很可能相同？
//   设一共邀请n个人，令第i,j,k个人生日相同的指示器随机变量
//      Aijk = 1  i,j,k生日相同
//             0  i,j,k生日不同
//    则Pr{Aijk} = 求和(i=1 to 365)(1/365)的3次方 = (1/365)的平方
//    三人生日相同的组数的期望为: 
//       E[A] = 求和(i=1 to n)(求和(j=i+1 to n)(求和(k=j+1 to n)(Aijk)))
//            = 求和(i=1 to n)(求和(j=i+1 to n)(求和(k=j+1 to n)(1/365)的平方))
//            = (n(n-1)(n-2))/(6*(365)的2次方)
//    令E>=1 ,n >= 94

// 5 在大小为n的集合中，一个k字符串构成一个k排列的概率是多少？这个问题和生日悖论有什么关系？
//   P = (An(k))/((n-k)! * n的k次方)

// 6 假设将n个球投入n个箱子里，其中每次投球独立，并且每个球等可能落入任何箱子。空箱子的数目期望是多少?正好有一个球的箱子的数目期望是多少？
//   设第i号箱子为空的事件为Ai，概率为Pr{Ai} = (1 - 1/n)的n次方
//   当n比较大的时候， Pr{Ai} = 1/e
//   则空箱子数量的期望为: E(A) = 求和(i=0 to n-1)(Ai)
//                              = 求和(i=0 to n-1)(1/e)
//                              = n/e
//   则有一个球的箱子的期望是: E(B) = 求和(i=0 to n)(Bi)
//                                  = 求和(i=0 to n)(1/e)
//                                  = (n+1)/e

// 7 为使特征序列长度的下界变得更精确，请说明在n次硬币的公平抛掷中，不出现比lgn - 2lglgn更长的连续正面特征序列的概率小于1/n
//   设表示从第i项开始连续出现k个正面的事件，则：
//     Pr{Ai} = (1/2)的lgn - 2lglgn次方 = (lgn)的平方/n
//   则出现比lgn - 2lglgn更长的连续正面特征序列概率：
//     Pr >= 求和(i=1 to n-(lgn - 2lglgn)+1) (Pr{Ai})
//         = 求和(i=1 to n-(lgn - 2lglgn)+1) ((lgn)的平方/n)

// h1 概率计数
//    利用一个b位计数器，一般只能计数到2的b次方-1. 而用R.Mprris概率计数法，可以计数到一个大的多的值，但是精度会有损失。
//    对i=0,1,...,2的b次方-1，令计数器值i表示ni的计数，其中ni构成了一个非负的递增序列。假设计数器初值为0，表示计数n0=0.
//    Increment运算单元工作在一个计数器上，以概率的方式包含值i。如果i=2的b次方-1，则运算单元报告溢出错误；否则，以概率1/(ni+1 - ni)把计数器加1，以概率1 - 1/(ni+1 - ni)保持计数器不变。
//    对所有i>=0,若选择ni=i，次计数器就是普通计数器。若选择ni=2的i-1次方(i>0)或ni=Fi(第i个斐波那契数),则出现更多情形。
//    假设n(2的b次方 - 1)已足够大，发生溢出错误的概率可忽略。
//  1 说明执行n次Increment操作后，计数器表示的数期望值正好是n。
//    E[Xj] = 0*P{keep} + 1*P{increases}
//          = 0*(1 - 1/(ni+1 - ni)) + 1*(ni+1 - ni)*(1/(ni+1 - ni))
//          = 1
//    执行n次后，E[X] = n
//  2 分析计数器表示的计数的方差依赖于ni序列。一个简单情形：对所有i>=0,ni=100i。在执行n次Increment操作后，请估计计数器所表示数的方差。
//    单次方差: Var[Xj] = E[Xj平方] - (E[Xj])的平方
//                      = 0*99/100 + 100平方*1/100 - 1
//                      = 99
//    整体方差为：Var[X] = Var[X1 + X2 +...+Xn] = 99n

// h2 查找一个无序数组，在一个包含n个元素的无序数组A中查找一个值x。
//    随机策略：随机挑选一个A中的下标i。如果A[i]=x则终止；否则，继续挑选A中的一个新的随机下标。
//              重复随机挑选下标，直到找到一个下标j，使A[j]=x,或者直到我们已检查了所有元素。
// 1 Random_Search实现如上策略。
//   Random_Search(x,A,n)
//   1 v = 空集
//   2 while v != n   //v的大小
//   3       i = Random(1,n)
//   4       if A[i] = x
//   5          return i
//   6       else
//   7          v = v ∩ i
//   8 return NULL
// 2 假定恰好有一个下标i使得A[i] = x.在我们找到x和Random_Search结束之前，必须挑选A下标的数目期望是？
//   伯努利试验，期望n
// 3 假设有k>=1个下标i使得A[i]=x，推广对2的解答。在找到x或Random_Search结束之前，必须挑选A的下标数目期望为？
//   期望n/k   E[X] = 求和(i=1 to n-k) (i*(1-k/n)的n-k-1次方*k/n)
// 4 假设没有下标i使得A[i]=x.在检查完A的所有元素或Random_Search结束之前，必须挑选A的下标数目期望为？
//   球箱问题，期望n(lnn + O(1))
//    现考虑一个确定性的线性查找算法，称为Deterministic_Search
//    该算法在A中顺序查找x，考虑A[1],A[2],...,A[n],直到找到A[i]=x或者到达末尾。假设输入数组的所有排列等可能。
// 5 假设恰好有一个下标i满足。Deterministic_Search平均情形的运行时间为？最坏情形运行时间为？
//   平均情形为(n+1)/2    E[T] = 求和(i=1 to n)(i*1/n)  , 最坏情形为n
// 6 假设有k>=1个下标满足，推广对5的解答。
//   平均情况为(n-k+2)/2 ,最坏情况为 n-k+1
// 7 假设没有下标满足，求平均与最坏
//   平均与最坏都为n
//    最后随机算法Scramble_Search它先将输入数组随机变换排列，然后在变换后的数组上运行Deterministic_Search算法
// 8 设k是满足A[i]=x的下标数目，请给出k=0，k=1时，最坏运行时间和运行时间期望。推广k>=1的情况。
//   情况与Deterministic_Search相同(因为考虑原数组就是随机的，再随机打乱对后续分析没有影响)




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 附录C.2 概率
// 借助样本空间S来定义概率。 S:基本事件的集合。每个基本事件可以视为某个试验的一个可能结果。

// 事件时样本空间S的一个子集。 事件S称为必然事件，事件空称为空事件。
// 如果事件满足A∩B=空，则事件AB是互斥的。
// 将基本事件s属于S看做事件{s}，所有基本事件都是互斥的。

// 概率论公理
// 样本空间S上的概率分布Pr{}是一个从S的事件到实数的映射，满足如下概率论公理：
//   1 对于任意事件A，Pr{A}>=0
//   2 Pr{S}=1
//   3 对于两个互斥事件AB，有Pr{A∪B} = Pr{A} + Pr{B} 。更一般的，对于任意事件序列Ai（i=1，2，...），其两两互斥，有Pr{∪iAi} = 求和i(Ai)
// 称Pr{A}为事件A的概率。由此引申出如下公式：
//   1 Pr{空} = 0
//   2 若A属于B，则Pr{A} <= Pr{B}
//   3 用A`表示S-A（A的补），则Pr{A`} = 1 - Pr{A}
//   4 对任意两个事件AB Pr{A∪B} = Pr{A} + Pr{B} - Pr{A∩B} <= Pr{A} + Pr{B}

// 离散概率分布
// 如果一个概率分布定义在有限或者无限可数的样本空间上，则该概率分布是离散的。
// 令S是样本空间，对于任意事件A，因为基本事件是互斥的，所以有： Pr{A} = 求和(s属于A) (Pr{s})
// 如果S有限，且每个基本事件s属于S的概率为 Pr{s} = 1/|S|
// 则得到的概率分布为S上的均匀概率分布。这种情况下，常从S中随机选择一个元素来描述实验。

// 连续均匀概率分布
// 在连续均匀概率分布中，不是所有样本空间的子集都被看做事件。
// 连续均匀概率分布定义在实数闭区间[a,b]上(a<b)。 区间上每一点都是等可能的。
// 由于区间有无穷点，若每点有同样有限正概率，则违反公理。因此赋予S部分子集以概率
// 对于闭区间[c,d](a<=c<=d<=b),连续均匀概率分布定义事件[c,d]的概率为： Pr{[c,d]} = (d-c)/(b-a) 因此任意一点的概率为0
// 此外 Pr{[c,d]} = Pr{(c,d)}

// 条件概率与独立
// 知道一些关于试验结果的先验知识，条件概率形式化了这部分。
// 已知事件B发生，事件A的条件概率定义为：Pr{A|B} = Pr{A∩B}/Pr{B}
// 也可以理解为，已知B发生，此时A也发生的概率，即B条件下AB同时发生的概率。
// 若Pr{A∩B} = Pr{A}Pr{B} ，则称两个事件是独立的，若Pr{B}不等于0，则其等价于条件概率 Pr{A|B} = Pr{A}
// 如果对于所有1<=i<j<=n，有Pr{Ai∩Aj} = Pr{Ai}Pr{Aj}，则称事件A1，A2，...,An两两独立，它们的子集也满足该等式

// 贝叶斯定理
// 根据条件概率的定义与交换律A∩B=B∩A，对于两个概率不为0的事件A和B，有：
//     Pr{A∩B} = Pr{B}Pr{A|B} = Pr{A}Pr{B|A}
//     Pr{A|B} = Pr{A}Pr{B|A}/Pr{B}
// 以上公式称为贝叶斯定理
// 因为   B = (B∩A)∪(B∩A~)，且B∩A与B∩A~是互斥事件。
// 所以   Pr{B} = Pr{B∩A} + Pr{B∩A~} = Pr{A}Pr{B|A} + Pr{A~}Pr{B|A~}
// 变形得 Pr{A|B} =  Pr{A}Pr{B|A}/(Pr{A}Pr{B|A} + Pr{A~}Pr{B|A~})
// 该定理可以简化条件概率的运算。


// test
// 1 甲抛一枚均匀硬币一次，乙抛一枚均匀硬币两次，甲得到正面朝上结果多于乙的概率?
//   1/2 x 1/4 = 1/8

// 2 证明布尔不等式，对于有限或可数无限事件序列Ai
//   Pr{∪iAi}<= Pr{A1} + Pr{A2} +...
//   Pr{∪iAi} = Pr{A1} + Pr{A2} +... - Pr{∩iAi}
//            <= Pr{A1} + Pr{A2} +...  (when Ai为相互独立事件时取等号)

// 3 假设10张牌，标有1到10的数字，打乱。从牌堆一次一张移除三张牌，依次选出三张牌按照递增顺序排列的概率为？
//   A1：第一张抽到1（1/10） 第二张抽到2（1/9）第三张随便
//                       第二张抽到3（1/9）第三张7/8
//   。。。。。。
//   1/10 x 1/9 x 1/8 x (8+7+6+5+4+3+2+1)
//   A2：第一张抽到2 1/10 x 1/9 x 1/8 x (7+6+5+4+3+2+1)
//   。。。。。。
//   A7：第一张抽到7 1/10 x 1/9 x 1/8 x (2+1)
//   A8：第一张抽到8 1/10 x 1/9 x 1/8 x 1
//   Pr{A} = 求和(1 to 8) Pr{Ai} = 120/720 = 1/6

// 4 证明：Pr{A|B} + Pr{A~|B} = 1
//   Pr{A|B} = Pr{A}Pr{B|A}/(Pr{A}Pr{B|A} + Pr{A~}Pr{B|A~})
//   Pr{A~|B} =  Pr{A~}Pr{B|A~}/(Pr{A}Pr{B|A} + Pr{A~}Pr{B|A~})
//   Pr{A|B} + Pr{A~|B} = (Pr{A}Pr{B|A} + Pr{A~}Pr{B|A~})/(Pr{A}Pr{B|A} + Pr{A~}Pr{B|A~})
