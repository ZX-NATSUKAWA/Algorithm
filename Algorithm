// 算法在计算中的作用
// 1.1 算法Algorithm
//   任何良定义的计算过程，将某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法在这个过程中就是一系列计算步骤的序列。
//   对一个问题的阐述，表明期望的输入/输出关系，算法描述了一个特定过程来实现这种关系。
//   正确的算法：输入实例算法以正确的输出停机。
//   不正确的算法在错误率可控时可能是可用的。
//   算法问题共有的特征：1 存在许多候选解，找尽可能的最优解。  2 存在实际应用。

// 1.1.1  以排序问题举例：
//     输入：n个数的序列
//     输出：输入序列的一个排列，满足一定关系
//     给定输入序列，称为排序问题的一个实例。   问题实例由计算该问题必须的（满足问题中的各种约束）输入组成。
//   排序问题在应用中选择算法的影响因素：将被排序的项数、这些项已被排序的程度、项值的限制、计算机体系结构、存储设备种类。

// 1.1.2 数据结构：一种存储和组织数据的方式，旨在便于访问和修改。

// 1.1.3 技术：无法用已有算法来解决问题时，能够自行设计算法、证明正确性、计算其效率。

// 1.1.4 难题
//   对于有效算法，用产生结果需要的时间来衡量其效率。
//   对于未知有效算法的问题，称之为难题。
//       如：NP完全问题（Non-deterministic Polynomial Problem/多项式复杂程度的非确定性问题）
//       1 现状：目前仍未找到对NP完全问题的有效算法
//       2 其性质：如果任一Np完全问题存在有效算法，那么所有NP完全问题都存在有效算法。
//       3 意义：有几个NP完全问题类似存在有效算法的问题，但不完全等同。可以用对问题陈述的小变动来极大改变已有算法的效率。
//       所以，如果一个问题NP完全，可以有有效算法去解决，但不一定是最佳算法，这种算法被称为“近似算法”。

// 1.1.5 并行性
//   单线程：一个计算核心处理问题，一步一步顺序往下运行。（随着功率提高，存在物理限制，不能无限提高性能）
//   多线程（并行）：用多个计算核心，分解问题，每个核心负责部分运算。（可以通过增加核心量来提高计算效率）
//   因此为了从多核计算机获取最佳性能，设计算法时要考虑并行性。


// 1.2.2 算法与其他技术
//   其他对系统性能重要的技术：
//     先进的计算机体系结构与制造技术
//     易于使用、直观的图形用户界面
//     面向对象的系统
//     集成的万维网技术
//     有线与无线的快速组网



// 算法基础
// 介绍一个贯彻始终的框架，后续的算法设计与分析都基于这个框架，就像骨头上长出肌肉、血管乃至皮肤。
// 以排序问题的插入排序算法为例，引入伪代码说明算法执行步骤、功能，分析其运行时间。
// 引入分治法开发归并排序算法，分析其运行时间。

// 2.1 插入排序
//   选出一个数，从左向右（其实就是按一个顺序）依次比较，然后放入合适的位置。
// 例
//int main()
//{
//	int arr[5];
//	int i, j, t;
//	printf("输入5个元素：");
//	for (i = 0; i < 5; i++)
//		scanf_s("%d", &arr[i]);
//	for (j = 1; j < 5; j++)       // 指出正在被插入的当前数。
//	{
//		t = arr[j];
//		i = j - 1;
//		while (i >= 0 && arr[i] > t) //循环不变式
//		{
//			arr[i + 1] = arr[i];
//			i = i - 1;
//		}
//		arr[i + 1] = t;
//	}
//	for (i = 0; i < 5; i++)
//		printf("%d ", arr[i]);
//	return 0;
//}
// 循环不变式三条性质
//     1 初始化：循环第一次迭代之前为真。（循环起码能运行一次）
//     2 保持：如果循环某次迭代为真，那下次迭代之前仍为真。（保证未满足终止条件时，循环能正常继续下去）
//     3 终止：循环终止时，证明算法是正确的。（类似for，while循环的终止条件）
// 伪代码中的一些约定：
//       1 缩进代表块结构。
//       2 退出循环后，计数器保持当前值。
//       3 符号//后内容表示注释。
//       4 多重赋值表达式，r如i=j=e,将e的值赋给i和j。
//       5 若无特殊说明，变量均为局部变量。
//       6 数组元素通过数组名[下标]来访问。
//       7 复合数据通常被组织成对象，对象又由属性组成。对象名.属性名，可以逐级向下访问。
//         把表示一个数组或对象的变量看做是其指针。y=x后，xy指向相同的对象。
//         属性记号还可串联。如f指向g，记作f.g，又x.f.g。如果y=x.f ,根据上一条有x.f.g = y.g
//         空指针可以记作NIL
//       8 按值把参数传递给过程，当对象被传递时，指向表示对象数据的指针被复制而其属性没有。

// 2.2 分析算法
//   分析算法的结果意味着预测算法需要的资源。通过分析求解某个问题的候选算法，从中选出最有效的。
//   分析前要使用一个实现技术的模型（一台假想电脑）。本书中假定为一种通用的单处理器计算模型（随机访问机）
//   RAM模型包含真实计算机的常见指令：算术指令、数据移动指令、控制指令。每条指令所需时间均为常量。
//          数据类型：整数型、浮点型。 对每个数据字节假定一个范围以符合使用需要、实际情况。
//          分析过程需要使用到的数学工具可能包括：组合学、概率论、代数技巧，识别一个公式中最具意义的项。
//          通常只选一种机器模型来分析某个给定的算法。
