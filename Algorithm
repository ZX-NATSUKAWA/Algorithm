// 算法在计算中的作用
// 1.1 算法Algorithm
//   任何良定义的计算过程，将某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法在这个过程中就是一系列计算步骤的序列。
//   对一个问题的阐述，表明期望的输入/输出关系，算法描述了一个特定过程来实现这种关系。
//   正确的算法：输入实例算法以正确的输出停机。
//   不正确的算法在错误率可控时可能是可用的。
//   算法问题共有的特征：1 存在许多候选解，找尽可能的最优解。  2 存在实际应用。

// 1.1.1  以排序问题举例：
//     输入：n个数的序列
//     输出：输入序列的一个排列，满足一定关系
//     给定输入序列，称为排序问题的一个实例。   问题实例由计算该问题必须的（满足问题中的各种约束）输入组成。
//   排序问题在应用中选择算法的影响因素：将被排序的项数、这些项已被排序的程度、项值的限制、计算机体系结构、存储设备种类。

// 1.1.2 数据结构：一种存储和组织数据的方式，旨在便于访问和修改。

// 1.1.3 技术：无法用已有算法来解决问题时，能够自行设计算法、证明正确性、计算其效率。

// 1.1.4 难题
//   对于有效算法，用产生结果需要的时间来衡量其效率。
//   对于未知有效算法的问题，称之为难题。
//       如：NP完全问题（Non-deterministic Polynomial Problem/多项式复杂程度的非确定性问题）
//       1 现状：目前仍未找到对NP完全问题的有效算法
//       2 其性质：如果任一Np完全问题存在有效算法，那么所有NP完全问题都存在有效算法。
//       3 意义：有几个NP完全问题类似存在有效算法的问题，但不完全等同。可以用对问题陈述的小变动来极大改变已有算法的效率。
//       所以，如果一个问题NP完全，可以有有效算法去解决，但不一定是最佳算法，这种算法被称为“近似算法”。

// 1.1.5 并行性
//   单线程：一个计算核心处理问题，一步一步顺序往下运行。（随着功率提高，存在物理限制，不能无限提高性能）
//   多线程（并行）：用多个计算核心，分解问题，每个核心负责部分运算。（可以通过增加核心量来提高计算效率）
//   因此为了从多核计算机获取最佳性能，设计算法时要考虑并行性。


// 1.2.2 算法与其他技术
//   其他对系统性能重要的技术：
//     先进的计算机体系结构与制造技术
//     易于使用、直观的图形用户界面
//     面向对象的系统
//     集成的万维网技术
//     有线与无线的快速组网



// 算法基础
// 介绍一个贯彻始终的框架，后续的算法设计与分析都基于这个框架，就像骨头上长出肌肉、血管乃至皮肤。
// 以排序问题的插入排序算法为例，引入伪代码说明算法执行步骤、功能，分析其运行时间。
// 引入分治法开发归并排序算法，分析其运行时间。

// 2.1 插入排序
//   选出一个数，从左向右（其实就是按一个顺序）依次比较，然后放入合适的位置。
// 例
//int main()
//{
//	int arr[5];
//	int i, j, t;
//	printf("输入5个元素：");
//	for (i = 0; i < 5; i++)
//		scanf_s("%d", &arr[i]);
//	for (j = 1; j < 5; j++)       // 指出正在被插入的当前数。
//	{
//		t = arr[j];
//		i = j - 1;
//		while (i >= 0 && arr[i] > t) //循环不变式
//		{
//			arr[i + 1] = arr[i];
//			i = i - 1;
//		}
//		arr[i + 1] = t;
//	}
//	for (i = 0; i < 5; i++)
//		printf("%d ", arr[i]);
//	return 0;
//}
// 循环不变式三条性质
//     1 初始化：循环第一次迭代之前为真。（循环起码能运行一次）
//     2 保持：如果循环某次迭代为真，那下次迭代之前仍为真。（保证未满足终止条件时，循环能正常继续下去）
//     3 终止：循环终止时，证明算法是正确的。（类似for，while循环的终止条件）
// 伪代码中的一些约定：
//       1 缩进代表块结构。
//       2 退出循环后，计数器保持当前值。
//       3 符号//后内容表示注释。
//       4 多重赋值表达式，r如i=j=e,将e的值赋给i和j。
//       5 若无特殊说明，变量均为局部变量。
//       6 数组元素通过数组名[下标]来访问。
//       7 复合数据通常被组织成对象，对象又由属性组成。对象名.属性名，可以逐级向下访问。
//         把表示一个数组或对象的变量看做是其指针。y=x后，xy指向相同的对象。
//         属性记号还可串联。如f指向g，记作f.g，又x.f.g。如果y=x.f ,根据上一条有x.f.g = y.g
//         空指针可以记作NIL
//       8 按值把参数传递给过程，当对象被传递时，指向表示对象数据的指针被复制而其属性没有。

// 2.2 分析算法
//   分析算法的结果意味着预测算法需要的资源。通过分析求解某个问题的候选算法，从中选出最有效的。
//   分析前要使用一个实现技术的模型（一台假想电脑）。本书中假定为一种通用的单处理器计算模型（随机访问机）
//   RAM模型包含真实计算机的常见指令：算术指令、数据移动指令、控制指令。每条指令所需时间均为常量。
//          数据类型：整数型、浮点型。 对每个数据字节假定一个范围以符合使用需要、实际情况。
//          分析过程需要使用到的数学工具可能包括：组合学、概率论、代数技巧，识别一个公式中最具意义的项。
//          通常只选一种机器模型来分析某个给定的算法。

// 2.2.1 插入排序算法的分析（asymptotic analysis渐进分析）
//   2.2.1.1 插入排序过程需要的时间依赖输入规模。 一般来说，算法需要时间随输入规模同步增长，所以将一个程序的运行时间描述为输入规模的函数。
//       输入规模：依赖研究的问题。对不同问题，输入规模的量度不同（单位不同）。
//       运行时间：执行的基本操作数或步数
//   分析过程中，由繁到简地改进运行时间表达式，并用简单记号表示语句代价Ci（忽略具体的实际代价），更关注增长率。
//               假定注释是不可执行语句，不需要运行时间。
//   2.2.1.2 现分析伪代码如下：
//   for j=2 to A.length           c1  n
//       key = A[j]                c2  n-1
//       // insert A[j] into sort   0  n-1
//       i=j-1                     c4  n-1
//       while i>0 and A[i]>key    c5  tj(for j=2 to n求和)
//             A[i+1] = A[i]       c6  tj-1(for j=2 to n求和)
//             i = i -1            c7  tj-1(for j=2 to n求和)
//       A[i+1] = key              c8  n-1
//   算法运行时间=代价 x 次数 的总和
//   T(n) = c1n + c2(n-1) + c4(n-1) + c5(求和tj) + c6(求和tj-1) + c7(求和tj-1) + c8(n-1)
//       最佳情况 T(n) = (c1+c2+c4+c5+c8)n - (c2+c4+c5+c8) = an - b
//       最坏情况 T(n) = (c5/2+c6/2+c7/2)nn + (c1+c2+c4+c5/2-c6/2-c7/2+c8)n - (c2+c4+c5+c8) = ann + bn + c
//   注：通常运行时间对给定输入是固定的，但是也有一些随机化算法（对固定输入，其行为可能变化导致运行时间不定）

// 2.2.2 最坏情况和平均情况的分析
//     往往只考虑求最坏情况的运行时间，即对于输入规模n，算法最长运行时间。
//         最坏情况运行时间给出任何输入的运行时间上界，能确保该算法绝不会超出这个运行时间。
//         对于某些算法，最坏情况经常出现。
//         平均情况往往和最坏情况一样差。
//         随机化算法中，假定给定规模的所有输入具有相同的可能性，以允许进行概率分析并产生某个期望的运行时间。
// 注：期望是一种均值，是试验中每次可能结果的概率 x 结果的总和，用于反应随机变量平均取值大小。

// 2.2.3 增长量级
//   使用简化抽象以化简分析。
//       Ci表示代价以忽略实际代价。常量a,b,c忽略Ci进一步简化
//       关注增长率，只考虑最重要的项，如最高次项。
//       当忽略低价项及最重要项的常系数时，使用asymptotic notation（theta），记为o(最重要项因子)


// 2.3 设计算法
//   插入排序使用了增量方法（排序好子列后，将后面的元素插入子列）
//   分治法，其最坏运行时间比插入排序要少得多。
// 2.3.1 分治法
//   在算法结构上是递归的：为了解决一个给定问题，一次或多次递归调用自身来解决相关的子问题。
//   思想：原问题分解为规模较小且类似的子问题，递归求解子问题，合并子问题的解来求出原问题的解。
//   步骤：分解，解决，合并。  当待排序列长度为1时，递归开始回升。
//   2.3.1.1 
//     MERGE(A,p,q,r) 合并函数，用于合并子数列A[p...q]和A[q+1...r],结果为A[p...r]
//     过程MERGE需要o(n)的时间 n=r-p+1（待合并元素总数），每次比较两个数组的当前元素，较小的放到输出数组中，放一次比一次，直到n个元素全放入输出数组。
//     如果当一个数组已经全部放入输出数组，则另一个数组剩余元素没有必要继续比较，可直接顺次放入输出数组。所以在数组底部放特殊值，当比较时出现该值可直接跳过比较。
//     伪代码如下：
//     MERGE(A,p,q,r)
//       n1=q-p+1
//       n2=r-q
//       //let L[1...n1+1]  and R[1...n2+1] be new arrays
//       for i=1 to n1
//           L[i] = A[p+i-1]
//       for j=1 to n2
//           R[j] = A[q+j]
//       L[n1+1] = infinitas
//       R[n2+1] = infinitas
//       i = 1
//       j = 1
//       for k=p to r
//           if L[i] <= R[j]
//              A[k] = L[i]
//              i = i + 1
//           else A[k] = R[j]
//                j = j + 1
//     MERGE-SORT (A,p,r)
//       if p<r
//          q=[(p+r)/2] (取整)
//           MERGE-SORT (A,q,r)
//           MERGE-SORT (A,q+1,r)
//           MERGE (A,p,q,r)
//     C语言封装成函数如下： //(有问题)
//void Merge(char arr[],int p,int q,int r)
//{
//	int i, j, k, n1, n2;
//	n1 = q - p;
//	n2 = r - q;
//	char L[5], R[5];
//	for (i = 0; i < n1; i++)
//		L[i] = arr[p + i];
//	for (j = 0; j < n2; j++)
//		R[j] = arr[q + j];
//	L[i + 1] = 'N';
//	R[i + 1] = 'N';
//	i = 0;
//	j = 0;
//	for (k = p; k < r; k++)
//	{
//		if (L[i] <= R[j])
//		{
//			arr[k] = L[i];
//			i++;
//		}
//		else
//		{
//			arr[k] = R[j];
//			j++;
//		}
//	}
//}
//void Merge_sort(char arr[], int p, int r)
//{
//	int q = 0;
//	if (p < r)
//	{
//		q = (p + r) / 2;
//		Merge_sort(arr, p, q);      // 左列排序
//		Merge_sort(arr, q + 1, r);  // 右列排序
//		Merge(arr, p, q, r);        // 合并左右列
//	}
//}
//int main()
//{
//	int i;
//	char arr[6] = { '2','6','4','5','9','1' };
//	int p = 0;
//	int r = sizeof(arr);
//	/*printf("%d", r);*/
//	Merge_sort(arr, p, r);
//	for (i = 0; i < r; i++)
//		printf("%c ", arr[i]);
//	return 0;
//}

// test
// 2.3-2 重写MERGE，不用哨兵。
//   MERGE(A,p,q,r)
//   n1=q-p+1
//   n2=r-q
//   for i=1 to n1
//       L[i]=A[p+i-1]
//   for j=1 t0 n2
//       R[j]=A[q+j]
//   i=1
//   j=1
//   while i<=q and j<=r
//        for k=p to r
//          if L[i]<=R[j]
//             A[k]=L[i]
//             i=i+1
//          else A[k]=R[j]
//               j=j+1
//   while k<=r  
//        if i == q+1
//           A[k]=R[j]
//           k=k+1
//           j=j+1
//         else
//           A[k]=L[i]
//           k=k+1
//           j=j+1

// 2.3.4 插入排序：为排序A[1...n],递归排序A[1...n-1],然后插入A[n]，求最坏运行时间递归式
//   1 分解：当数组只剩一个元素时，耗时为常量，记作o(1)
//   2 解决：递归求解n-1个元素，需要时间T(n-1)
//   3 合并：一个具有n-1个元素的数组，插入第n个元素需要时间cn
//   递归式 T(n) = o(1)         n=1
//               = T(n-1) + cn  n>1

// 2.3.5 二分法查找最坏运行时间
//   BINARY_SEARCH(A,x)
//     low=1
//     high=A.length
//     while low<=high
//       mid=(low+high)/2
//       if A[mid] == x
//          return mid
//       elseif A[mid]<x
//          low=mid+1
//       else
//          high=mid-1
//   T(n+1)=T(n/2)+c  最坏运行时间o(lgn)

// 2.3.7 给定n个整数的集合S和另一个整数x，确定S中是否存在两个和刚好为x的元素，其运行时间为o(nlgn)
//   SUM_FIND(S,x)
//     MERGE_SORT(S,1,S.length) // 先将S从小到大归并排序 o(nlgn)
//     for i=1 to S.length      // 再二分法查找是否存在两个数和为x。 需要时间： n x o(lgn) = o(nlgn)
//         if BINARY_SEARCH(S,x-S[i]) != nil // 找到了
//            return ture
//     return false                          // 没找到
//     总运行时间为o(nlgn)

// 2.1 在归并排序中对小数组采用插入排序
//   1 插入排序：排序n/k个长度为k的子表。排序一个需要T(k)=akk+bk+c,n/k个T=n/k(akk+bk+c)=ank+bn+cn/k=o(nk)
//   2 递归式 T(a)= 0          a=1
//              = T(a/2)+ak  a=2
//     归纳得 T(a)=aklga
//     T(n/k)=nlg(n/k)   so  o(nlg(n/k))
//   3 o(nk+nlg(n/k))<=o(nlgn)
//     so k<=lg(n/k)   k max 满足k2k次幂<n
//   4 当递归的子问题耗时大于直接插入排序时对应的k即为所求

// 2.2 冒泡排序正确性
//   1 还需证明A'中的所有元素就是A中各个元素
//   2 证明j循环的循环不变式
//     初始化：第一轮迭代开始前，只有j=A[length]一个元素，显然已排序，所以第一轮迭代之前已成立
//     保持：  迭代之前，假设A[j]...A[length]是已排序的，待排序元素A[j-1]依次与A[j]...A[length]比较，
//             如果A[j-1] > A[j],则交换位置，此时整个数列已排好序。
//             即j成立情况下，j-1也成立，证明其迭代过程中保持成立。
//     终止：  当i=A.length-1时，j=A.length,A'[1...n]个元素都已排好序。
//   3 证明i,j循环不变式
//     初始化：第一次循环开始时，A[1...i-1]为空数组，循环不变式成立。
//     保持：  A[1...i-1]满足循环不变式条件，j循环保证A[i]为A[i...n]中最小的元素。
//             迭代之前，A[1...i-1]内是已升序排序的数组，且A[i]大于A[1...i-1]中每个元素
//             即A[1...i-1]成立条件下，A[1...i]也成立,证明其迭代过程中保持成立。
//     终止：  i=n,A[1...n-1]满足循环不变式，由于A[1...n-1]由数组中最小的数组成，则A[n]必大于[1...n-1]所有数，则A[1...n]已排好序。
//   4 冒泡排序最坏运行时间o(nn),且无论是否已排好序。每次都执行判断，循环总次数不变,实际运行时间恒等于o(nn).
//     插入排序最坏运行时间o(nn),一旦找到插入位置循环结束，实际运行时间<=o(nn)
//     总体而言，插入排序性能更佳

// 2.3 霍纳Horner规则正确性
//   给定系数ai(i=1...n)和x的值
//   y=0
//   for i=n downto 0
//       y=ai + xy
//   实现了求值多项式 P(x) = 求和ak(x的k次幂) = a0 + x(a2+...+x(an-1+xan)...))
//   1 o(n)
//   2 嵌套循环城际结果累加 o(nn),比霍纳规则慢
//   3 证明循环不变式
//     初始化：i=n,y=0,循环不变式成立。
//     保持：  迭代开始时，y=求和(k=0,n-i-1)a(k+i+1)(x的k次幂)
//             循环后y = ai+x求和(k=0,n-i-1)a(k+i+1) = ai(x的0次幂)+求和(k=1,n-i)a(k+i)(x的k次幂)
//             y = a(k+i)(x的0次幂) + 求和(k=1,n-i)a(k+i)(x的k次幂) = 求和(k=0,n-i)a(k+i)(x的k次幂)迭代过程中保持成立。
//     终止：i=-1 ,y=求和(k=0,n)ak(x的k次幂)

// 2.4 逆序对 数组元素大小顺序与下标顺序相反
//   1 2，3，8，6，1的五个逆序对 ： (3,4),(3,5),(4,5),(1,5),(2,5)
//   2 {n...2,1}具有最多逆序对，有(n-1+1)(n-1)/2
//   3 INSERTION_SORT(A):
//        c=0
//        for j=2 to A.length
//            key=A[j]
//            i=j-1
//            while i>0 and A[i]>key
//                  A[i+1]=A[i]
//                  i=i-1
//                  c=c+1
//             A[i-1]=key
//    Prove：
//          1 初始化：第一次循环开始前，c=0，A[1]只有一个元素，不存在逆序对，不变式成立。
//          2 保持：  c为当前A[1...j-1]的逆序对个数。
//                    本次循环时，在A[1...j-1]中找比A[j]大的元素，直至退出子循环。
//                    循环结束A[1...j-1]都比A[j]小，A[j+1...n]都比A[j]大。此时c为A[j]与A[1...j-1]的逆序对个数，不变成成立。
//          3 终止：   j=A.length+1，c为A[1...n]的逆序对个数。
//    4 
//int Merge(int arr[], int p, int q, int r)
//{
//	int c = 0, k = 0, i, j;
//	int n1 = q - p + 1;
//	int n2 = r - q;
//	int* L = (int*)malloc((n1+1) * sizeof(int));
//	int* R = (int*)malloc((n2+1) * sizeof(int));
//	for (i = 0; i < n1; i++)
//		*(L + i) = arr[p + i];
//	for (j = 0; j < n2; j++)
//		*(R + j) = arr[q + 1 + j];
//	*(L + i) = 100;
//	*(R + j) = 100;
//	i = 0;
//	j = 0;
//	for (k = p; k <= r; k++)
//	{
//		if (*(L + i) <= *(R + j))
//		{
//			arr[k] = *(L + i);
//			i++;
//		}
//		else
//		{
//			arr[k] = *(R + j);
//			j++;
//			c++;
//		}
//	}
//	//while( i<=q && j<=r)
//	//{
//	//	for (k = p; k <= r; k++)
//	//	{
//	//		if (*(L + i) <= *(R + j))
//	//		{
//	//			arr[k] = *(L + i);
//	//			i++;
//	//		}
//	//		else
//	//		{
//	//			arr[k] = *(R + j);
//	//			j++;
//	//			c++;
//	//		}
//	//	}
//	//}
//	//while (k <= r)
//	//{
//	//	if (i == q + 1)
//	//	{
//	//		arr[k] = *(R + j);
//	//		k++;
//	//		j++;
//	//	}	
//	//	else
//	//	{
//	//		arr[k] = *(L + i);
//	//		k++;
//	//		j++;
//	//	}
//	//}
//	free(L);
//	free(R);
//	return c;
//}
//int Merge_sortC(int arr[], int p, int r)
//{
//	int c = 0;
//	if (p < r)
//	{
//		int q = (p + r) / 2;
//		return Merge_sortC(arr, p, q) + Merge_sortC(arr, q + 1, r) + Merge(arr, p, q, r);
//	}
//	else
//		return 0;
//}

//int Merge_sort(int a[], int p, int q, int r)
//{
//	int t[5];
//	int c = 0;
//	int i = p;
//	int j = q + 1;
//	for (int k = p; k <= r; k++)
//	{
//		if ((j > r) || (i <= q) && (a[i] <= a[j]))
//			t[k] = a[i++];
//		else
//		{
//			t[k] = a[j++];
//			c += q - i + 1;
//		}
//	}
//	for (i = p; i <= r; i++)
//		a[i] = t[i];
//	return c;
//}
//int Merge_sortC(int a[], int p, int r)
//{
//	if (p < r)
//	{
//		int q = p + (r - p) / 2;
//		return Merge_sortC(a, p, q) + Merge_sortC(a, q + 1, r) + Merge_sort(a, p, q, r);
//	}
//	else
//		return 0;
//}
//int main()
//{
//	int arr[5] = { 2,3,8,6,1 };
//	int c = Merge_sortC(arr, 0, 4);
//	printf("%d", c);
//	return 0;
//}



// 函数增长
//   虽然有时能确定一个算法的精确运行时间，但是通常不值得计算获得多余精度。
//   当输入规模足够大时，只与运行时间的增长量级有关时，研究算法的渐进效率。

// 3.1 渐进记号
//   用来描述算法渐进运行时间的记号根据定义域为自然数集N的函数来定义。 （对整数输入规模）
//   但采用渐进记号更为方便。（目的还是为了简化）

// 3.1.1 渐进记号、函数与运行时间
//   如插入排序，其最坏运行时间可写为函数T(n)=ann+bn+c,使用渐进记号o(nn)来描述它。
//   除时间函数外，渐进记号还可以描述算法的其他方面，如：空间数量，甚至是与算法无关的函数。
//   使用渐进记号来描述算法运行时间，不光是最坏运行时间，更希望是对所有输入的，因此有完全适合任何输入的运行时间的渐进记号。
//   3.1.1.1 theta记号
//   对于一个给定函数g(n),用theta(g(n))来表述以下函数的集合：
//   theta(g(n)) = {f(n):存在正常量c1,c2和n0，使得对所有n >= n0,有0 <= c1g(n) <= f(n) <= c2g(n)}
//      解读：若存在正常数c1和c2，使得对于足够大的n，函数f(n)能夹入c1g(n)和c2g(n)之间，则f(n)属于集合o(g(n))。
//            因为theta(g(n))是一个集合，，所以f(n)是它的成员，可以记为f(n)属于theta(g(n))，替代记为f(n)=tehta(g(n))
//            类似于夹逼准则，对所以n>=n0,f(n)在常量因子内等于g(n),称g(n)是f(n)的一个渐进紧确界。
//            定义要求，每个成员f(n)均渐进非负（c>0 nn>0,f夹在两者之间必非负）
//   简单记忆：只保留最高次项。 准确定义：如上。
//   Prove:  c1nn <=   ann+bn+c    <= c2nn    // 必有a>0
//           c1   <=  a+b/n+c/nn   <= c2      // 对不同n，可确定不同c1、c2,反之亦可。
//           c1/a <=  1+b/an+c/ann <= c2/a    // 进一步，最高次项的系数也可以忽略。
//          一般性的，对任意d阶多项式p(n),有p(n)=o（n的d次方）
//   3.1.1.2 O记号
//   相对theta记号给出一个函数的上界和下界，当只有一个渐进上界时，使用O记号。
//   对于一个给定函数g(n),用O(g(n))来表述以下函数的集合：
//   O(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0,有0 <= f(n)<= cg(n)}
//      解读：给出函数的上界，即对n0及其右边的所有n值，f(n) <= cg(n)
//            记f(n)=O(g(n)). 注意f(n)=o(g(n))中包含f(n)=O(g(n))。
//            当使用f(n)=O(g(n))时，仅仅要求g(n)的某个常数倍是f(n)的上界，但这个上界并不一定紧确。
//            使用O记号描述上界，可以仅通过算法的总体结构来描述算法运行时间,但由于输入变化，其最坏运行时间为O(nn)，但其他情况下不是。
//   3.1.1.3 Omiga记号
//   Omiga记号提供了函数下界。
//   对于一个给定函数g(n),用Omiga(g(n))来表述以下函数的集合：
//   Omiga(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0，有0 <= cg(n) <= f(n)}
//      解读：给出函数的上界，即对n0及其右边的所有n值，cg(n) <= f(n)

// 3.1.2 定理3.1
//   对于任意两个函数f(n)和g(n),有f(n)=o(g(n))。当且仅当f(n)=O(g(n))且f(n)=Omiga(g(n)).
//   对于ann+bn+c=0(nn)，实际应通过定理3.1从渐进确界获取渐进上下界，用渐进上界和下界证明渐进确界。
//   算法的最佳情况运行时间为Omiga，最坏运行情况时间为O，所以算法运行时间就在两者确定的渐进确界之间，需要时间为o

// 3.1.3 等式和不等式中的渐进记号
//   渐进记号可以用于数学公式中。
//   当渐进记号独立于等式或不等式一侧时，已经明确等号所指的集合关系。但渐进记号出现于在某个公式中时，将其解释为匿名函数。
//      如：2nn+3n+1=2nn+theta(n) 意为 2nn+3n+1=2nn+f(n)  f(n)为theta(n)中的某个函数。称f(n)为匿名函数。
//          总之利用渐进记号，消除等式中无关杂项（多为低阶项）。
//          一个表达式中匿名函数的数目可以理解为等于渐进记号出现的次数。
//   当渐进记号出现在等式一侧时，如： 2nn+theta(n)=theta(nn)
//         无论怎样选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。
//         等式右边是等式左边的进一步简化版。
//   3.1.3.1 o记号
//     O记号提供的渐进上界可能不是紧确的。如：2nn=O(nn)是紧确的 2n=O(n)却不是。
//     因此采用o记号来表示一个非渐进紧确的上界。 对于一个给定函数g(n),用o(g(n))来表述以下函数的集合：
//     o(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0,有0 <= f(n)< cg(n)}
//     极限n趋于无穷，f(n)/g(n)=0,可以作为o记号的定义。
//   3.1.3.2 w记号
//     w记号于Omiga记号的关系类似o记号与O记号的关系。 用w记号表示一个非渐进紧确的下界。
//     对于一个给定函数g(n),用w(g(n))来表述以下函数的集合：
//     w(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0，有0 <= cg(n) < f(n)}
//     极限n趋于无穷，f(n)/g(n)=无穷,可以作为o记号的定义。
//     也可以利用o记号定义： f(n) belong w(g(n))     only when     g(n) belong o(f(n))
//   3.1.3.3 应用
//     实数的许多关系性质也适用于渐进比较。 假定f(n)、g(n)渐进为正。
//     1 传递性
//       f(n)=theta(g(n))  and   g(n)=theta(h(n))    so   f(n)=theta(h(n))
//       f(n)=O(g(n))      and   g(n)=O(h(n))        so   f(n)=O(h(n))
//       f(n)=Omiga(g(n))  and   g(n)=Omiga(h(n))    so   f(n)=Omiga(h(n))
//       f(n)=o(g(n))      and   g(n)=o(h(n))        so   f(n)=o(h(n))
//       f(n)=w(g(n))      and   g(n)=w(h(n))        so   f(n)=w(h(n))
//     2 自反性
//       f(n) = theta(f(n))
//       f(n) = O(f(n))
//       f(n) = Omiga(f(n))
//     3 对称性
//       f(n) = theta(g(n))  only when  g(n) = theta(f(n))
//     4 转置对称性
//       f(n) = O(g(n))      only when  g(n) = Omiga(f(n))
//       f(n) = o(g(n))      only when  g(n) = w(f(n))
//     5 类比
//       O      a<=b  ;   o  a<b
//       Omiga  a>=b  ;   w  a>b
//       theta  a=b
//     6 三分性
//       对任意两个实数a，b，必存在三种关系中的某一种:a<b,a=b,a>b
//       但对于函数并不一定，即不是所有函数都可以渐进比较。


// test
// 3.1.1 
//   c1f(n) <= f(n) <= c2f(n)
//   c3g(n) <= g(n) <= c4g(n)
//   不妨设f(n) >= g(n)，则max(f(n),g(n))=f(n)
//   所以存在c5,c6，满足c5（f(n)+g(n)) <= f(n)=max(f(n),g(n)) <= c6(f(n)+g(n))
//   即证max(f(n),g(n))  =  theta(f(n)+g(n))

// 3.1.2
//   将（n+a）的b次方，多项式展开得，最高次项为n的b次方.
//   所以（n+a）的b次方 = theta(n的b次方)

// 3.1.3
//   O记号代表算法运行时间上限，与表述“运行时间至少”相矛盾。

// 3.1.4
//   2的(n+1)次方 = 2x2的n次方 = O(2的n次方) 成立 
//   2的2n次方    = 2的n次方 x 2的n次方 不等于 cx2的n次方  不成立

// 3.1.5 
//   因为 f(n) = theta(g(n))
//   所以 f(n)满足 c1g(n) <= f(n) <= c2g(n)
//   即同时满足  c1g(n) <= f(n)      ,   f(n) <= c2g(n)
//   即同时满足  f(n) = Omiga(g(n))  ,   f(n) = O(g(n))
//   所以 f(n) = theta(g(n)) 与 f(n) = Omiga(g(n))，f(n) = O(g(n))同时成立 两者等价。

// 3.1.6
//   类3.1.5证明。 Omiga(g(n))代表算法下界（最好情况运行时间），O(g(n))代表算法上界（最坏情况运行时间）

// 3.1.7
//   反证法  设存在f(n) = o(g(n))∩w(g(n))
//   则f(n)满足 f(n)<c1g(n)  且 f(n)>c2g(n)>=0
//   因为c1,c2是任意常数，令c1=c2，则 cg(n)<f(n)<cg(n)
//   不存在f(n)满足上不等式，矛盾，故o(g(n))∩w(g(n))为空集。

// 3.1.8
//   记号有两个参数的情况（n,m）
//   O(g(n,m)) = {f(n,m):存在正常量c、n0和m0,使得对所有n>=n0或m>=m0,有0 <= f(n,m) <= cg(n,m)}
//   Omiga(g(n,m)) = {f(n,m):存在正常量c、n0和m0,使得对所有n>=n0或m>=m0,有0 <= cg(n,m) <= f(n,m)}
//   theta(g(n,m)) = {f(n,m):存在正常量c1、c2、n0和m0,使得对所有n>=n0或m>=m0,有0 <= c1g(n,m) <= f(n,m) <= c2g(n,m)}


// 3.2 标准记号与常用函数
// 3.2.1 单调性
//   m<=n f(m)<=f(n),则函数f(x)单调递增     ; m<=n f(m)>=f(n)，则函数f(x)单调递减。
//   m<n  f(m)<f(n) ,则函数f(x)严格单调递增 ; m<n  f(m)>f(n)，则函数f(x)严格单调递减。

// 3.2.2 向下取整与向上取整
//   [x]表示小于或等于x的最大整数（读作x的向下取整）； [X]表示大于或等于x的最大整数（读作x的向上取整）
//   对所有实数x： x-1 < [x] <= x <= [X] < x+1
//   对任意整数n： [n/2] + [N/2] = n
//   对任意实数x>=0和整数a,b>0: [[X/A]/B] = [X/AB]
//                              [[x/a]/b] = [x/ab]
//                              [A/B]     <= (a+(b-1))/b
//                              [a/b]     >= (a-(b-a))/b
//   向下取整和向上取整函数都是单调递增的。

// 3.2.3 模运算
//   对任意整数a和任意正整数n，a mod n的值就是商a/n的余数：
//                             a mod n = a - n[a/n]
//                             0 <= a mod n < n
//   a mod n = b mod n时，记a=b(mod n) 称模n时，a等价于b。（即a模n与b模n有相同的余数）

// 3.2.4 多项式
//   给定一个非负整数d，n的d次多项式为p(n) = 求和(i=0到d)ai(n的i次方)
//   其中ai为多项式系数且ad不等于0
//   一个多项式为渐进正的 当且仅当ad>0，有p(n)=theta(n的d次方)。
//   对任意实常量a>=0,函数n的a次方单调递增；对任意实常量a<=0,函数n的a次方单调递减。
//   若对某常量k，有f(n)=O(n的k次方),则称函数f(n)是多项式有界的。

// 3.2.5 指数
//   n的b次方 = o(a的n次方)  (a>0)
//   对任意实数x:  e的x次方 >= 1+x  (x=0时取等号)
//   当|x|<=1时 :  1+x <= e的x次方 <= 1+x+xx  
//   当x趋于0时 :  e的x次方 = 1+x+theta(xx)

// 3.2.6 对数
//   对x>-1 : x/(1+x) <= ln(1+x) <= x  (x=0时取等号)
//   对任意常量a>0 : (lgn)的b次方 = o(n的a次方)

// 3.2.7 阶乘
//   n! = 1        n=0
//      = n(n-1)!  n>0
//   n! = 1x2x3x......xn
//   阶乘函数的一个弱上界是n! <= n的n次方。 因为阶乘中每一项小于等于n
//       斯特林近似公式： n! = 根号下(2pien) x (n/e)的n次方 x (1+theta(1/n))  给出一个更紧确的上界和下界。
//   对所有n>=1  n! = 根号下(2pien) x (n/e)的n次方 x e的an次方 。  其中 1/(12n+1) < an < 1(12n)

// 3.2.8 多重函数
//   f(i)(n)表示函数f(n)重复i次作用于一个初值n上
//   f(i)(n) = n            i=0
//           = f(f(i-1)(n)) i>0

// 3.2.9 多重对数函数
//   lg*n = min{i>=0: lg(i)n<=1}

// 3.2.10 斐波那契数
//   F0 = 0
//   F1 = 1
//   Fi = Fi-1 + Fi-2  i>=2
//   斐波那契数与黄金分割率及其共轭数有关，是方程xx=x+1的两个根
//   Fi = (黄金分割率i - 其共轭数i)/根号5 = [黄金分割率i/根号5 + 1/2]


// test
// 3.2.1 证明单调性
//   设a,b是定义域上任意两点，且a<b
//   因为f(n),g(n)单调递增，所以f(a)<=f(b),g(a)<=g(b)
//   所以f(a)+g(a)<=f(b)+g(b),即函数f(n)+g(n)单调递增
//   所以f(g(a))<=f(g(b)),即函数f(g(n))单调递增
//   若f(n),g(n)>=0,则0<=f(a)g(a)<=f(b)g(b),则函数f(n)g(n)单调递增。

// 3.2.2 证明a的logb(c) = c的logb(a)
//   等式两端同取logc：logb(c)logc(a)     logb(a)logc(c)
//                     logb(a)       =    logb(a) 等式成立，即证

// 3.2.3 证明lg(n!) = theta(nlgn)
//   lg(n!)=lg1 + lg2 + ... +lgn <= lgn + lgn + ... +lgn = nlgn
//   所以lg(n!) = theta(nlgn)
//   n! = 1x2x...xn < nxnx...xn = n的n次方,所以n!= o(n的n次方)
//   n! = 1x2x3x4...xn > 2x2x2x...x2 =2的n次方，所以n! = w(2的n次方)

// 3.2.4 证明[lgN]!无界，[lg(lgN)]!有界
//   首先，f(n)多项式有界的充分必要条件是 lgf(n) = O(lgn) （存在常数c和n0，当n>=n0时，f(n)<c*n的k次方）
//   1 设f(n)=(lgn)!   存在常数c和n0，当n>=n0时，lg(f(n)) >= c(lgn)lg(lgn)
//     由于lg(lgn)是单调递增函数，总可以在n >= n0的范围内找到n >= n1，使得clg(lgn) >= 1
//     则此时lg(f(n)) >= lgn，并不能满足lgf(n) = O(lgn).  所以(lgn)!并不是多项式有界函数。
//   2 设f(n)=(lglgn)! 由公式3.2.3，lg(n!)=theta(nlgn)，得lg(f(n))=lg((lglgn)!) = theta(lg(lgn(lglglgn)))
//     因为对于任意的n > 1，lglglgn < lglgn，则存在常数c和n0，使得n >= n0时，lg(f(n)) <= c(lglgn)²
//     又因为任意多项式函数都比任意多对数函数增长快，所以c(lglgn)² = O(lgn), 所以lg(f(n)) = O(lgn),则f(n) = (lglgn)!多项式有界。

// 3.2.5 
//   lg*(lgn)=lg*n+1   lg(lg*n)为lg*n的对数函数，因而lg*(lgn)渐进更大些

// 3.2.6
//   黄金分割率及其共轭数带入方程xx=x+1即证

// 3.2.8
//    证明klnk = theta(n) 蕴含着k=theta(n/ln(n)).
//    当klnk = theta(n)时，则存在正常量c1, c2和n0,使得对所有n ≥ n0,有0 ≤ c1∗n ≤ nln(n) ≤ c2∗n 
//    此时n>=1,有0<=c1*n/(lnn) <= n <= c2*n/(lnn)，即证

// 3.1 
//   https://blog.csdn.net/victoryaoyu/article/details/76237944

// 3.2 相对渐进增长 （k>=1 e>0 c>1且均为常量）
//   (lgn)的k次方 <=   n的e次方
//   n的k次方     <=   c的n次方
//   根号n        no   n的sinn次方
//   2的n次方     >=   2的(n/2)次方
//   n的lgc次方   =    c的lgn次方
//   lg(n!)       =    lg(n的n次方)

// 3.3 根据渐进增长率排序 (g1=Omiga(g2)=Omiga(g3)=...=Omiga(g30))
//   2的(2的(n+1)次方)次方
//   2的(2的n次方)次方
//   (n+1)!
//   n!
//   e的n次方
//   n(2的n次方)
//   2的n次方
//   (3/2)的n次方
//   n的(lglgn)次方 = (lgn)的lgn次方
//   (lgn)!
//   n的3次方
//   n的平方 = 14的(lgn)次方
//   nlgn 近似于 lg(n!)
//   n = 2的lgn次方
//   (根号2)的lgn次方
//   2的根号2lgn次方
//   (lgn)的平方
//   lnn
//   根号lgn
//   lnlnn
//   2的(lg*n)次方
//   lg*n 近似于 lg*(lgn)
//   lg(lg*n)
//   1 = n的(1/lgn)
//   不是上述函数上界或下界的函数 (2的(2的(2的(n+1)次方))次方)的sinx次方

// 3.4 渐进记号的性质
// f(n) = O(g(n)) 不等价于 g(n) = O(f(n))   如 n=O(nn)
// f(n)+g(n) 不等于 theta(min{f(n),g(n)})   如 n+nn 不等于 theta(min{n,nn})
// f(n) = O(g(n)) 等价于 lg(f(n)) = O(lg(g(n)),其中对所有足够大的n，有lg(g(n))>=1且f(n)>=1
// f(n) = O(g(n)) 不等价于 2的f(n)次方=O(2的g(n)次方)  如 2n=O(n),4的n次方不等于O(2的n次方)
// f(n)>=1时，f(n) = O((f(n))的平方) ；f(n)<1时，不成立。
// f(n) = O(g(n)) 等价于 g(n) = Omiga(f(n))
// f(n) 不等于 theta(f(n/2))   如 n! 不等于 theta((n/2)!)
// f(n)+o(f(n)) = theta(f(n))

// 3.5 Omiga无穷：若存在正常量c，使得对无穷多个整数n，有f(n)>=cg(n)>=0，则称f(n)=Omiga无穷(g(n))
//   1 对渐进非负的任意两个函数f(n)和g(n),或者f(n)=O(g(n))或者f(n)=Omiga无穷(g(n))或者两者均成立。但Omiga替代Omiga无穷时，命题为假。
//     若f(n) 不等于 O(g(n)) ,则必有无穷多个正整数n，使f(n)>=cg(n)>=0,即f(n)=Omiga无穷成立。
//     若f(n) = theta(g(n)),则两者同时成立。
//     若用Omiga替代Omiga无穷则不一定成立，如n=Omiga无穷(n的sinn次方),但n不等于Omiga(n的sinn次方)
//   2 Omiga无穷替代Omiga
//     优点：Omiga无穷对下界要求更宽松，可以兼容更多情况。
//     缺点：Omiga无穷不是严格的渐进下界，实际意义不大。
//   3 O'：f(n)=O'(g(n)) only when  |f(n)|=O(g(n))
//     用O'替代O仍使用Omiga，对定理3.1没有影响。
//     因为f(n)=O(g(n))成立代表f(n)渐进非负，所有|f(n)|=f(n)。
//   4 定义软O记号，意指忽略对数因子的O：
//     软O(g(n)) = {f(n):存在正常量c,k,n0,使得对所有n>=n0,有0<=f(n)<=cg(n)(lg(n))的k次方}
//     类似定义软Omiga和软theta
//     软Omiga(g(n)) = {f(n):存在正常量c,k,n0,使得对所有n>=n0，有0<=cg(n)(lg(n))的k次方<=f(n)}
//     软theta(g(n)) = {f(n):存在正常量c1,c2,k1,k2,n0,使得对所有n>=n0,有0<=c1g(n)(lg(n))的k1次方<=f(n)<=c2g(n)(lg(n))的k2次方}

// 3.6 多重函数：将用于函数lg*的多重操作符*应用于实数集上的任意单调递增函数f(n).
//   对给定常量c属于R，定义多重函数fc*(n) = min{i>=0,f(i)(n)<=c}
//   该函数不必在所有情况下都良定义。值fc*(n)是为缩小其参数到c或更小所需函数f重复应用的次数。
//   对于每个函数f(n)和常数c，给出fc*(n)的一个尽量紧确的界。
//   f(n)          c          fc*(n)
//   n-1           0          theta(n)
//   lgn           1          theta(lg*n)
//   n/2           1          theta(lgn)
//   n/2           2          theta(lgn)
//   根号n         2          theta(lglgn)
//   根号n         1          无法收敛
//   n的1/3次方    2          theta(log3(lgn))
//   n/lgn         2          w(lglgn),o(lgn)



// 分治策略
// 分解、解决、合并。 子问题足够大时，递归求解，称之为递归情况；子问题足够小时，递归触底，进入基本情况。
// 有时除了与原问题完全一样的子问题外，还有不完全一样的将其归入合并步骤。
//   递归式
//     一个等式或不等式，通过更小的输入来描述一个函数。 子问题的规模不一定是原问题规模的一个固定比例。
//     求解递归式的方法：代入法、递归树法、主方法。
//   递归式技术细节
//     实际应用中会忽略递归式声明和求解一些技术细节。 如：向下取整或向上取整、边界条件。

// 4.1 最大子数组问题
//   以股票为例，利益最大化即最低价买入最高价卖出。
//   若最高价出现在最低价之前，则无法实现理想的利益最大化，因而实际的利益最大化是买入（不一定是最低价）和卖出（不一定是最高价）的差价最高。
//  4.1.1 暴力求解法
//    对可能的买进和卖出日期全部组合一边，从中遍历出最大值。 运行时间为Omiga(nn)
//  4.1.2 问题变换
//    不再从每日价格的角度看待数据，而是考虑每日价格变化。
//    第i天价格变化定义为：第i天和第i-1天的价格差。 将价格变化看做一个数组A，则问题转化成找A的和最大的非空连续子数组（最大子数组）。
//    最大子数组可能不止一个
//    目前该方法仍需检查（n-1，2）=theta(nn)个子数组，和暴力求解法近似.
//  4.1.3 分治策略
//    设寻找子数组A[low...high]的最大子数组。
//    将数组尽可能分成两个规模相等的子数组，分别找其内部的最大子数组。
//    最大子数组A[low...high]的任何连续子数组A[i...j]必然位于以下三种情况之一：
//      1 完全位于子数组A[low...high]中。
//      2 完全位于子数组A[mid+1...high]中。
//      3 跨越mid。
//      对于情况3，将数组分为左右两个数组，分别找出左右的最大子数组，再将它们合并即为所求。
//      Find_Max_Crossing_Subarray(A,low,mid,high)
//    1 left-sum = - 无穷
//    2 sum = 0
//    3 for i=mid downto low     // 从中点往左找最大子数组
//    4     sum = sum + A[i]     // 求子数组的和
//    5     if sum >left-sum     // 如果求和大于之前的最大值
//    6        left-sum = sum    // 赋值，即为当前左数组的最大子数组
//    7        max-left = i      // 记录左边界
//    8 right-sum = -无穷        // 原理同求左数列
//    9 sum = 0
//   10 for i=mid+1 to high
//   11     sum = sum + A[i]
//   12     if sum>right-sum
//   13        right-sum = sum
//   14        max-right = i
//   15 retrun (max-left,max-right,left-sum+right-sum)
//   上述过程花费theta(n)的时间
//   下面用分治法求解最大子数组问题
//   Find_Maximum_Subarray(A,low,high)
//  1  if high == low
//  2     return (low,high,A[low])  // 数组只有一个元素
//  3  else mid = [(low+high)/2]    // 中点位置向下取整
//  4       (left-low,left-high,left-sum) = Find_Maximum_Subarray(A,low,mid)               // 情况1，求左数组中的最大子数组
//  5       (right-low,right-high,right-sum) = Find_Maximum_Subarray(A,mid+1,high)         // 情况2，求右数组中的最大子数组
//  6       (cross-low,cross-high,cross-sum) = Find_Max_Crossing_Subarray(A,low,mid,high)  // 情况3，求跨mid最大子数组
//  7  if left-sum >= right-sum and left-sum >= cross-sum         // 如果左数组的最大子数组最大，则它为整个数组的最大子数组
//  8     return (left-low,left-high,left-sum)
//  9  elseif right-sum >= letf-sum and right-sum >= cross-sum    // 如果右数组的最大子数组最大，则它为整个数组的最大子数组
// 10      return (right-low,right-high,right-sum)
// 11   else return (cross-low,cross-high,cross-sum)               // 如果cross数组的最大子数组最大，则它为整个数组的最大子数组
//  4.1.4 分治算法分析
//    1、2行花费常量时间。 T(1) = theta(1)
//    3花费常量时间。
//    4、5解决两个规模为n/2的子问题，每个子问题花费T(n/2)
//    6调用Find_Max_Crossing_Subarray,花费theta(n)
//    7-11花费theta(1)时间
//    总体花费T(n) = theta(1) + 2T(n/2) + theta(n) +theta(1) = 2T(n/2) + theta(n)
//    递归式： T(n) = theta(1)            n=1
//                  = 2T(n/2) + theta(n)  n>1
//    利用主方法，求解时间为T(n) = theta(nlgn)   (或者可以用递归树理解)


// test 
// 1 当A的所有元素为负数时，Find_Maximum_Subarray返回什么？
//   返回数组最大元素

// 2 对最大子数组，编写暴力求解方法的伪代码，运行时间为theta(nn)
//   Sum(A,low,high)
//     sum = 0
//     for i=low to high
//         sum += A[i]
//     return sum
// 
//   Find_Max_Subarray(A,n)
//     max_sum = -无穷
//     max_left = 0
//     max_right = 0
//     for i=1 to n
//       for j=i to n
//         temp_sum = sum(A,i,j)
//         if temp_sum > max_sum
//            max_sum = temp_sum
//            max_left = i
//            max_right = j
//     return (max_left,max_right,max_sum)

// 3 暴力算法和递归算法的性能交叉点
//   theta(nn) = theta(nlgn) 解出n0
//   在0-n0使用暴力算法，在n0到正无穷使用递归算法

// 4 修改最大子数组定义，允许空子数组为结果，其和为0.
//   if low = high and a[high]<0
//      return (-1,-1,0)

// 5 最大子数组的非递归、线性时间算法。
//   若A[1...j]为最大子数组，求A[1...j+1]的最大子数组。
//    A[1...j+1]的最大子数组要么是A[1...j]的最大子数组，要么是A[i...j+1].
//   Find_Max_Subarray(A,n)
//    low = 1
//    high = 1
//    sum = A[1]
//    for j=2 to n
//        temp_sum = 0
//        sum1 = A[j]
//        low1 = j
//        high1 = j
//        for i=j downto 1
//            temp_sum += A[i]
//            if temp_sum > sum1
//               sum1 = temp_sum
//               low1 = i
//        if sum1 > sum
//           sum = suum1
//           low = low1
//           high = high1
//     return(low,high,sum)


// 4.2 矩阵乘法的Strassen算法
//   需要计算nn个矩阵元素，每个元素是n个值的和。 给出伪代码如下：
//   Square_Matrix_Multiply(A,B)
//     n = A.rows
//     let C be a new nxn matrix
//     for i=1 to n
//         for j=1 to n
//             cij = 0
//             for k=1 to n
//                 cij = cij + aik x bik
//     return C
//   花费theta(nnn)时间
//   但使用Strassen的nxn矩阵相乘的递归算法，其运行时间为theta(n的lg7次方)

// 4.2.1 一个简单的分治算法
//   将n x n矩阵划分成4个n/2 x n/2的子矩阵构成的矩阵
//   对应C11 = A11 x B11 + A12 x B21，即每个公式对应两对n/2 x n/2矩阵乘法的加法。
//   直接的递归分治算法伪代码如下：
//   Square_Matrix_Multiply_Recursive(A,B)
//     n = A.rows
//     let C be a new nxn matrix
//     if n==1
//        c11 = a11 x b11
//     else partition A,B and C(利用下标)
//        c11 = Square_Matrix_Multiply_Recursive(A11,B11) + Square_Matrix_Multiply_Recursive(A12,B21)
//        c12 = Square_Matrix_Multiply_Recursive(A11,B12) + Square_Matrix_Multiply_Recursive(A12,B22)
//        c21 = Square_Matrix_Multiply_Recursive(A21,B11) + Square_Matrix_Multiply_Recursive(A22,B21)
//        c22 = Square_Matrix_Multiply_Recursive(A21,B12) + Square_Matrix_Multiply_Recursive(A22,B22)
//     return C
//  递归式 T(n) = theta(1)                        n=1
//              = theta(1) + 8T(n/2) + theta(nn)  n>1

// 4.2.2 strassen方法
//   在分治算法的基础上，只递归七次而不是8次。
//   步骤：
//     1 将A、B、C分解为n/2 x n/2子矩阵，theta(1)
//     2 创建10个n/2 x n/2的矩阵，每个矩阵保存1中两个子矩阵的和或差,theta(nn)
//     3 用1、2创建的矩阵，递归计算七个矩阵的积。
//     4 通过3计算的矩阵不同组合加减运算，计算出C的子矩阵，theta(nn)
//   步骤2中：S1=B12 - B22  S2=A11 + A12  S3=A21 + A22  S4=B21 - B11  S5=A11 + A22
//            S6=B11 + B22  S7=A12 - A22  S8=B21 + B22  S9=A11 - A21  S10=B11 + B12
//   步骤3中：P1=A11 x S1   P2=S2 x B22  P3=S3 x B11  P4=A22 x S4  P5=S5 x S6  P6=S7 x S8  P7=S9 x S10
//   步骤4中：C11 = P5 + P4 - P2 + P6 = A11 x B11 + A12 x B21
//            C12 = P1 + P2 = A11 x B12 + A12 x B22
//            C21 = P3 + P4 = A21 x B11 + A22 x B21
//            C22 = P5 + P1 - P3 - P7 = A22 x B22 + A21 x B12
//   递归式：T(n) = theta(1)             n=1
//                = 7T(n/2) + theta(nn)  n>1
//   递归式解为：T(n) = theta(n的lg7次方)


// test
// 1 使用Strassen算法计算矩阵乘法
//   S1=8-2=6 S2=1+3=4 S3=7+5=12 S4=4-6=-2 S5=1+5=6
//   S6=6+2=8 S7=3-5=-2 S8=4+2=6 S9=1-7=-6 S10=6+8=14
//   P1=6 P2=8 P3=72 P4=-10 P5=48 P6=-12 P7=-84
//   C11=26 C12=14 C21=62 C22=66

// 2 Strassen算法伪代码
//   Strassen(A,B)
//    let C be a new nxn matrix
//    if A.row == 1
//       C = A * B
//    else partition A,B,C
//       S1=B12 - B22  
//       S2=A11 + A12  
//       S3=A21 + A22 
//       S4=B21 - B11
//       S5=A11 + A22
//       S6=B11 + B22  
//       S7=A12 - A22
//       S8=B21 + B22  
//       S9=A11 - A21  
//       S10=B11 + B12
//       P1=A11 x S1   
//       P2=S2 x B22  
//       P3=S3 x B11
//       P4=A22 x S4
//       P5=S5 x S6
//       P6=S7 x S8
//       P7=S9 x S10
//       C11 = P5 + P4 - P2 + P6
//       C12 = P1 + P2
//       C21 = P3 + P4
//       C22 = P5 + P1 - P3 - P7
//    return C

// 3 修改strassen算法，使之适应矩阵规模不是2的幂的情况。
//   将矩阵扩展成2的[lgN] x 2的[lgN]矩阵，缺少的地方补0.

// 4 用k次乘法操作完成两个3x3矩阵相乘，可以在theta(n的lg7)时间内完成nxn矩阵相乘，满足条件k最大为多少，运行时间如何？
//   先将3x3矩阵补成4x4矩阵，k=4的lg7次方<=49

// 5 V.Pan算法，132464次乘法完成68x68矩阵乘法，143640次乘法完成70x70矩阵乘法，155424次乘法完成72x72矩阵乘法。
//   72x72矩阵会得到最佳渐进运行时间，其性能优于strassen算法。

// 6 strassen算法作为子进程处理kn x n矩阵乘n x kn矩阵，最快耗时？前后互换呢？
//   将A、B矩阵拆分为k个nxn矩阵，AxB=knxkn的矩阵，内部每个子矩阵相乘用strassen算法，theta(kkn的lg7次方)
//   反之，AxB=nxn的矩阵，theta(kn2的lg7次方)

// 7 三次实数乘法完成两个复数的相乘，接受abcd作为输入，输出实部和虚部。
//   A = (a + b)*c
//   B = (c + d)*b
//   C = (b - a)*d
//   (a + bi)*(c + di) = (A - B) + (B - C)i


// 4.3 用代入法求递归式
//   1 猜测解的形式
//   2 用数学归纳法求出解中的常数，并证明解的正确性                 
//   举例： 递归式T(n) = 2T([n/2]) + n,猜测其解为T(n)=O(nlgn)
//   证明：选择常数c>0，有T(n) <= cnlgn.
//         假设上界对所有m<n成立，对于m=[n/2],有T([n/2]) <= c[n/2]lg([n/2]).
//         so T(n) <= 2(c[n/2]lg([n/2])) + n <= cnlg(n/2) + n
//                  = cnlgn - cnlg2 + n
//                  = cnlgn - cn + n
//                 <= cnlgn (when c>=1)

// 4.3.1 做出好的猜测
//   1 靠经验、创造力和递归树。
//   2 先估计一个宽松的上下界，再逐步逼近渐进紧确界

// 4.3.2 微妙的细节
//   有时猜出了递归式的渐进界，但证明失败。问题在于归纳假设不够，应修改猜测，减去一个低阶项可能起效。
//   例：T(n) <= T([n/2]) + T([N/2]) + 1
//       猜测T(n) = O(n) T(n) <= cn,证明失败
//       再猜测T(n) <= cn - d
//             T(n) <= c[n/2]-d + c[N/2]-d + 1 <= cn- 2d + 1 <= cn - d  (when d>=1) 证明成立

// 4.3.3 避免陷阱
//   使用渐进符号容易出错，要证出与归纳假设严格一致的格式。
//   如：T(n) <= 2(c[n/2]) + n <= cn + n 不能证明T(n) <= cn 即T(n) = O(n)

//  4.3.4 改变变量
//    用代数运算将一个未知的递归式变成熟悉的形式。
//    如：T(n) = 2T([根号n]) + lgn
//        令 m = lgn 得到T(2的m次方) = 2T([2的m/2次方]) + m
//       变量代换后,S(m) = 2S(m/2) + m 有 S(m)=O(mlgm)
//       so T(n) = T(2的m次方) = S(m) = O(mlgm) = O(lgn lglgn)


// test
// 1 证明T(n) = T(n-1) + n的解为O(nn)
//   即证T(n) <= cnn - d
//   T(n) = T(n-1) + n
//       <= c(n-1)(n-1)+ n
//        = cnn - (2c-1)n + c  ( -(2c-1)n + c < 0)
//       <= cnn (when c>=n/(2n+1) 取c=1)

// 2 证明T(n) = T([N/2]) + 1的解为O(lgn)
//   即证T(n) <= clgn
//   T(n) = T([N/2]) + 1
//       <= clg([N/2]) + 1  (when n>=2,1<=[N/2]<=2n/3 )
//        = clgn + clg(2/3) + 1 (令 -clg(2/3) + 1 <0)
//       <= clgn (when c>1/lg(2/3))

// 3 证明T(n) = 2T([n/2]) + n的解为theta(nlgn)
//   即证c1[n]lg[n] <= T([n]) <= c2[n]lg[n]
//   对左不等式：
//   T(n) >= 2c[n/2]lg[n/2] + n
//        >= 2c(n/3)lg(n/3) + n
//         = (2/3)cnlgn - (2/3)cnlg3 + n (任意0<c<3/(2lg3))
//        >= (2/3)cnlgn

// 4 做出不同假设来克服T(n) = 2T([n/2]) + n的边界条件T(1) = 1
//   假设T(n) <= cnlgn + d (d>0)

// 5 证明归并排序的严格递推式的解为theta(nlgn)
//   任意m<n，存在c1、c2满足：c2mlgm <= T(m) <= c1mlgm
//   右不等式：T(n) <= 2c1[N/2]lg[N/2] + theta(n)
//                  <= 2(2/3)c1nlg(2n/3) + theta(n)
//                   = (4/3)c1nlgn + (4/3)c1nlg(2/3) + theta(n)
//                   = (4/3)c1nlgn
//    左不等式:T(n) >= 2c2[N/2]lg[N/2] + theta(n)
//                  >= 2(1/3)c2nlgn +theta(n)
//                   = (2/3)c2nlgn - c2(2/3)nlg3 + theta(n)
//                   = (2/3)c2nlgn

// 6 证明T(n) = 2T([n/2]+17) + n的解为O(nlgn)
//   即证T(n) <= cnlgn
//   T(n) = 2T([n/2]+17) + n
//       <= 2c([n/2]+17)lg([n/2]+17) + n (when n>=102,n/2+17>=2/3n)
//       <= (4/3)cnlgn + (4/3)cnlg(2/3) + n
//       <= (4/3)cnlgn (when c>=10)

// 7 使用主方法可以证明T(n) = 4T(n/3) + n的解为theta(n的log3(4)次方)
//   说明如何通过减去一个低阶项完成代入法证明。
//   不减低阶项时T(n) <= 4c((n/3)的log3(4)次方) + n，结构不严格一致，证明失败。
//   假设T(n) <= c(n的log3(4)次方) - dn
//   T(n) = 4T(n/3) + n
//       <= 4c((n/3)的log3(4)次方) - d(n/3) + n
//        = 4c(n的log3(4)次方) - (4/3)dn + n
//        = 4c(n的log3(4)次方) - (4d/3 - 1)n
//       <= 4c(n的log3(4)次方) - dn (when d>3)

// 8 使用主方法可以证明T(n) = 4T(n/2) + n的解为theta(nn)
//   说明如何通过减去一个低阶项完成代入法证明。
//   不减低阶项时T(n) <= cnn + n,结构不严格一致，证明失败。
//   假设T(n) <= cnn - dn
//   T(n) <= cnn  - dn + n
//         = cnn + (1-d)n (令1-d<0)
//        <= cnn (when d>1)

// 9 利用改变变量方法求解递归式T(n) = 3T(根号n) + lgn
//   令m = lgn,则n = 2的m次方，代入原式：T(2的m次方) = 3T(2的(m/2)次方) + m
//   令S(m) = T(2的m次方),则S(m) = 3S(m/2) + m
//   假设S(m) = theta(mlgm),c2mlgm <= S(m) <= c1mlgm
//   递归得c2(m/2)lg(m/2) <= S(m/2) <= c1(m/2)lg(m/2)
//   (3/2)c2mlgm - (3/2)c2mlg2 + n <= (3/2)c2mlg(m/2) + m <= S(m) <= (3/2)c1mlg(m/2) + m <= (3/2)c1mlgm - (3/2)c1mlg2 + m
//   when c1 >= 2/(3lg2) , c2 <= 2/(3lg2)
//     (3/2)c2mlgm <= S(m) <= (3/2)c1mlgm
//   so S(m) = theta(mlgm)
//   T(n) = T(2的m次方) = theta(lgn(lglgn))


// 4.4 用递归树求解递归式
//   画出递归树是设计好的猜测的一种简单而直接的方法。
//   一个结点表示一个单一子问题的代价，子问题对应某次递归函数的调用。
//   将树中每层代价求和，所有层代价总和即为总代价。
//   递归树最适合用来生成好的猜测，再用代入法验证猜测。
//   在建立递归树时，往往要忽略部分细节，来得到一个上界。


// test
// 1 对T(n) = 3T([n/2])+n,利用递归树确定一个好的渐近上界，用代入法验证。
//   假设n是2的幂
//   T(n) = n + (3/2)n + ((3/2)的平方)n + ... + ((3/2)的(lgn - 1)次方)n + theta(n的lg3次方)
//        = 求和(0到lgn - 1)(3/2)的i次方n + theta(n的lg3次方)
//        = 2(3的lgn次方) - 2n + theta(n的lg3次方)
//        = O(n的lg3次方)
//   证明T(n) <= cn的lg3次方 + n
//   T(n) = 3T(n/2) + 2n
//       <= 3c(n/2)的lg3次方 + 2n
//       <= cn的lg3次方 + 2n

// 2 对T(n) = T(n/2) + nn,利用递归树确定一个好的渐近上界，用代入法验证。
//   T(n) = nn + (1/4)nn + ((1/4)的平方)nn + ... + ((1/4)的(lgn - 1)次方)nn + T(1)
//        = 求和(0到lgn -1)((1/4)的i次方)nn + T(1)
//        < nn求和(0到无穷)((1/4)的i次方) + T(1)
//        = (4/3)nn + T(1)
//        = O(nn)
//   证明T(n) <= cnn
//   T(n) = T(n/2) + nn
//       <= (c/4)nn + nn
//        = (c/4 + 1)nn
//       <= cnn (when c > 4/3)

// 3 对T(n) = 4T(n/2+2) + n,利用递归树确定一个好的渐近上界，用代入法验证。
//   T(n) = n + (4(1/2)n+8) + (16(1/4)n+48) +...+ ((4的lgn - 1次方)((1/2)的lgn - 1次方))n + (4的lgn - 1次方)((1/2)的lgn - 3次方+...+2) + theta(nn)
//        = n求和(0到lgn - 1)(2的i次方) + 求和(1到lgn - 1)(4的(i+1)次方 - 2的(i+2)次方) + theta(nn)
//        = nn - n + (1/3)(4nn - 8) + 4n - 8 +theta(nn)
//        = theta(nn)
//   证明T(n) <= cnn + 2n
//   T(n) = 4T(n/2+2) + n
//        < 4c(n/2)(n/2) + 2(n/2) + n
//        = cnn + 2n

// 4 对T(n) = 2T(n-1) + 1,利用递归树确定一个好的渐近上界，用代入法验证。
//   T(n) = 1 + 2 + 4 + ... + 2的n-2次方 + theta(2的n-1次方) = theta(2的n次方)
//   证明T(n) <= c(2的n次方) + n
//   T(n) = 2T(n-1) + 1
//       <= 2c(2的n-1次方) + (n-1) + 1
//       <= c(2的n次方) + n

// 5 对T(n) = T(n-1) + T(n/2) + n,利用递归树确定一个好的渐近上界，用代入法验证。
//   不是完全二叉树，从lgn到n-1为非完全层。推测T(n) = O(2的n次方)
//   证明T(n) <= c(2的n次方) - 4n
//   T(n) = T(n-1) + T(n/2) + n
//       <= c(2的(n-1)次方 + 2的(n/2)次方) - 4(n-1) - 4n/2 + n
//       <= c(2的(n-1)次方 + 2的(n/2)次方) - 5n + 1  (when n > 1/4)
//       <= c(2的(n-1)次方 + 2的(n/2)次方) - 4n      (when n > 2)
//       <= c(2的m次方) - 4n

// 6 对T(n) = T(n/3) + T(2n/3) + cn,利用递归树论证解为Omiga(nlgn),其中c为常数。
//   递归树知道log3(n)后才开始不完全，每层代价都为cn
//   T(n) >= Omiga(nlog3(n)) = Omiga(nlgn)

// 7 对T(n) = 4T([n/2]) + cn,利用递归树解一个渐进紧确界，用代入法验证。
//   T(n) = cn + 2cn + 4cn +...+ (4的lgn - 1次方)(cn)/(2的lgn - 1次方) + theta(nn)
//        = cn求和(0到lgn - 1)(2的i次方) + theta(nn)
//        = cn(2的lgn次方 - 1) + theta(nn)
//        = theta(nn)
//   证明T(n) <= cnn + 2cn
//   T(n) = 4T([n/2]) + cn
//       <= 4c(n/2)(n/2) + 2cn/2 + cn
//        = cnn + 2cn
//   T(n) = 4T([n/2]) + cn
//       >= 4c(n/2)(n/2) + 2cn/2 + cn
//        = cnn + 2cn
//    so T(n) = theta(nn)

// 8 对T(n) = T(n-a) + T(a) + cn,利用递归树解一个渐进紧确解，用代入法验证。
//   T(n) = cn + cn + c(n-a) + c(n-2a) +...+ c(n-(n/a - 1)a + a) + theta(1)
//        = cnn/a + c(n/a -1)a - ca求和(1 to (n-a)/a-1)i + theta(1)
//        = tehta(nn)
//   证明T(n) <= cnn
//   T(n) = T(n-a) + T(a) + cn
//       <= c(n-a)(n-a) + caa + cn
//       <= cnn - cn(2a-1) + caa + ca (when a>=1,n>(aa+a)/(2a-1))
//       <= cnn
//   证明T(n) >= cnn
//   T(n) = T(n-a) + T(a) + cn
//       >= c(n-a)(n-a) + caa + cn
//        = cnn - 2an + 2caa + cn
//        = cnn + (c-2a)n + 2caa
//       >= cnn (when c>=2a,a>=0)
//   so T(n) = theta(nn)

// 9 对T(n) = T(an) + T((1-a)n) + cn,利用递归树解一个渐进紧确解.
//   T(n) <= cnlg(1/(1-a))n <= cnlgn (1-a <= 1/2)
//   T(n) = Omiga(nlgn)
//   证明T(n) <= dnlgn
//   T(n) = T(an) + T((1-a)n) + cn
//       <= danlg(an) + c(1-a)nlg((1-a)n) + cn
//        = danlgn + d(1-a)nlgn + danlga + d(1-a)nlg(1-a) + cn
//       <= dnlgn + (d(alga + (1-a)lg(1-a))+c)n
//       <= dnlgn (when d >= -c/(alga + (1-a)lg(1-a))
//   so T(n) = theta(nlgn)


// 4.5 用主方法求解递归式
//   为形式如T(n) = aT(n/b) + f(n) 的递归式，提供了一种“菜谱”式求解方法
//     其中，a>=1 b>=1，f(n) 是渐近正函数。
//   牢记三种情况，可以很容易求解很多递归式.
//   T(n) = aT(n/b) + f(n) 描述这样一种算法：
//        将规模为n的问题分解为a个子问题，每个子问题规模为n/b。
//        递归解决a个子问题，每个花费时间T(n/b).
//        f(n)包含了问题分解和合并的代价。
//   从技术正确性来看，该方法不是良定义，因为n/b可能不是整数，但可以用[]替换且不影响递归式渐近性质。

// 4.5.1 主定理
//   定理4.1（主定理） 令a>=1,b>1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式： T(n) = aT(n/b) + f(n)
//                     其中将n/b解释为[n/b]或[N/b],则T(n)有如下渐近界：
//                         1 若对某个常数e>0有f(n) = O(n的(logb(a-e)次方)，则T(n) = theta(n的logb(a)次方)。
//                         2 若f(n) = theta(n的logb(a)次方)，则T(n) = theta(n的(logb(a))次方lgn)。
//                         3 若对某个常数e>0有f(n) = Omiga(n的(logb(a+e))次方)，且对某个常数c<1和所有足够大的n有af(n.b)<=cf(n)，则T(n) = theta(f(n))。
//   对三种情况，都将 f(n) 与 n的logb(a)次方 进行比较。直观上，前者更大，解如情况3；后者更大，解如情况1，两者相等，解如情况2.
//   实际上，不是简单小于、大于即可，而要是多项式的渐近小于(相差因子n的e次方)、大于(满足正则条件af(n/b) <= cf(n))
//   三种情况之间还存在其他可能，在这些范围内不能使用主定理。
//   附：正则条件：指在陈述某个定理时，限定它的使用范围。如果超出这个范围，会导致定理不成立。

// 4.5.2 使用主方法
//   分析对应a、b的值，判断 f(n) 与 n的logb(a)次方 的渐近大小。
//   确定主定理的哪种情况成立，即可得到解。


// test
// 1 主方法求渐近紧确界
//   a T(n) = 2T(n/4) + 1        theta(n的(1/2)次方)
//   b T(n) = 2T(n/4) + 根号n    theta(n的(1/2)次方lgn)
//   c T(n) = 2T(n/4) + n        theta(n)
//   d T(n) = 2T(n/4) + nn       theta(nn)

// 2 Caesar教授想设计一个渐近快于Strassen算法的矩阵乘法。
//   采用分治法，将矩阵分解为n/4 x n/4的子矩阵，分解和合并花费theta(nn)时间。
//   需要创建多少个子问题才能击败Strassen算法？
//   T(n) = aT(n/4) + theta(nn) 求a的最大整数值。
//   Strassen: theta(n的lg7次方)
//   Caesar:   theta(n的log4(a)次方)
//   log4(a) < lg7  so a<=48

// 3 使用主方法证明，二分查找递归式T(n) = T(n/2) + theta(1) 的解时T(n) = theta(lgn)
//   a=1  b=2  n的lgb(a)=1=f(n)
//   so situation2：T(n) = theta(n的logb(a)次方lgn) = theta(lgn)

// 4 主方法能用于递归式T(n) = 4T(n/2) + nnlgn吗？ 给出一个渐近上界
//   a=4  b=2  n的lgb(a)= nn 
//   f(n) = nnlgn 渐近大于 nn,但不存在e>0,使f(n) = Omiga(n的logb(a+e)次方)
//   So can not prove.
//   用递归树求解：
//   T(n) = 求和(0 to lgn - 1)nn(lgn - i) + theta(nn)
//        = (1/2)nn(lgn)的平方 + theta(nn)
//        = O(nn(lgn)的平方) (when c>=1)


// 4.6 证明主定理
//   1 分析主递归式，简化定义n为b的幂次。
//   2 分析扩展到所有整数n，应用向下和向上取整的数学技巧。
//   3 稍微滥用渐近符号，用以描述b的幂上的函数行为。  当然，再有限值域上应用渐近符号应当小心，避免错误结论。

// 4.6.1 对b的幂证明主定理
//   引理4.2 令a>=1.b>1是常数，f(n)是一个定义在b的幂上的非负函数。T(n)是定义在b的幂上的递归式：
//           T(n) = theta(1)        n=1
//                = aT(n/b) + f(n)  n=b的i次方(i为正整数)
//           T(n) = theta(n的logb(a)次方) + 求和(0 to logb(n-1))(a的j次方)f(n/(b的j次方))  (使用递归树求总代价)
//   从递归树看，主定理三种情况对应：
//       1 树的总代价由叶结点的代价决定
//       2 树的总代价均匀分布在树的所有层上
//       3 树的总代价由根结点的代价决定
//   引理4.3 令a>=1.b>1是常数，f(n)是一个定义在b的幂上的非负函数。g(n)是定义在b的幂上的函数：
//           g(n) = 求和(0 to logb(n-1)) (a的j次方)f(n/(b的j次方))
//           对b的幂，g(n)有如下渐近界：
//              1 若对某个常数e>0有f(n) = O(n的(logb(a-e))),则g(n) = O(n的logb(a)次方)
//              2 若f(n) = theta(n的logb(a)次方),则g(n) = theta(n的logb(a)次方lgn)
//              3 若对某个常数c<1和足够大的n有af(n/b) <= cf(n),则g(n) = theta(f(n))
//   引理4.4 利用4.3的界和4.2的和式进行求值。
//           1 T(n) = theta(n的logb(a)次方) + O(n的logb(a)次方)        = theta(n的logb(a)次方)
//           2 T(n) = theta(n的logb(a)次方) + theta(n的logb(a)次方lgn) = theta(n的logb(a)次方lgn)
//           3 T(n) = theta(n的logb(a)次方) + theta(f(n))              = theta(f(n))

// 4.6.2 向下取整和向上取整
//   通过向下或向上取整，将递归式定义在所有整数上。
//   上下界证明类似，以上界证明为例。
//   nj(表示序列中第j个元素) = n        j=1
//                           = [Nj-1/b] j>0
//   nj <= n/b的j次方 + 求和(0 to j-1)(1/b的i次方) < n/b的j次方 + 求和(0 to 无穷)(1/b的i次方) = n/b的j次方 + b/(b-1)
//   令j=[logb(n)], nj < b + b/(b-1) = O(1)
//   T(n) = theta(n的logb(a)次方) + 求和(0 to [logb(n)]-1)(a的j次方)f(nj)
//   f(nj) <= c(n/b的j次方 + b/(b-1))的logb(a)次方 <= O(n的logb(a)次方/a的j次方)


// test 
// 1 对b是正整数而非任意实数的情况，给出公式(4.27)中nj的简单而准确的表达式
//   nj = [N/b的j次方]

// 2 Show that if f(n) = theta(n的logb(⁡a)次方(lgn)次方), where k≥0k≥0, then the master recurrence has solution T(n)=theta(n的logb(a)次方(lgn)的k次方).
//   For simplicity, confine your analysis to exact powers of b.
//   g(n) = 求和(0 to logb(n-1)) (a的j次方f(n/b的j次方))
//   代入f(n) = theta(n的logb(⁡a)次方(lgn)次方)
//   g(n) = theta(求和(0 to logb(n-1)) a的j次方 x (n/b的j次方)的logb(⁡a)次方 x (lg(n/b的j次方))次方)
//        = n的logb(a)次方 x 求和(0 to logb(n-1)) (a/(b的logb(a)))的j次方 x (lg(n/b的j次方))次方)
//        = n的logb(a)次方 x 求和(0 to logb(n-1))(lg(n/b的j次方))次方)
//        = n的logb(a)次方 x 求和(0 to logb(n-1))((lgn)的k次方 - o((lgn)的k次方)
//        = n的logb(a)次方 x (logb(n)(lgn)的k次方 + logb(n) x o((lgn)的k次方)
//        = n的logb(a)次方 x theta(logb(n) x (lgn)的k次方)
//        = theta(n的logb(a)次方 x (lgn)的k+1次方)
//   T(n) = theta(n的logb(a)次方) + g(n) 
//        = theta(n的logb(a)次方) + theta(n的logb(a)次方 x (lgn)的k+1次方)
//        = theta(n的logb(a)次方 x (lgn)的k+1次方) 即证

// 3 证明主定理情况3被过分强调了，某种意义上，对某个常数c<1,正则条件af(n/b)<=cf(n)成立本身意味着存在常数e>0,使得f(n) = Omiga(n的logb(a+e)次方)
//   令A = a/c
//   af(n/b) <= cf(n) 等价为 Af(n/b) <= f(n)
//   Af(n) <= f(nb)
//   A的i次方f(n) <= f(n(b的i次方))
//   A的i次方f(1) <= f(b的i次方)
//   令n = b的i次方，i = logb(n),则
//   f(n) = A的logb(n)次方 x f(1) = Omiga(n的logb(A))  (A>a 等价于 A=a+d when c<1,d>0)
//   等价于 f(n) = n的(logb(a) + logb(d))次方 = n的logb(a+e)次方 (when e=logb(d))


// hard test
// 1 给出每个递归式的渐近上下界，并验证。假定n<=2时，T(n)是常数。
// a T(n) = 2T(n/2) + nnnn
//   a=2,b=2,n的logb(a)次方=n < f(n)=nnnn
//   T(n) = theta(nnnn)
//   Prove: T(n) <= cnnnn
//   T(n) = 2T(n/2) + nnnn
//       <= 2c(n/2)的4次方 + nnnn
//        = (c/8+1)nnnn
// b T(n) = T(7n/10) + n
//   a=1,b=7,n的logb(a)次方=1 < f(n)=n
//   T(n) = theta(n)
//   Prove: T(n) <= cn
//   T(n) = T(7n/10) + n
//       <= c(7n/10) + n
//        = (7c/10 + 1)n
// c T(n) = 16T(n/4) + nn
//   a=16,b=4,n的logb(a)次方=nn = f(n)=nn
//   T(n) = theta(nnlgn)
//   Prove: T(n) <= cnnlgn
//   T(n) = 16T(n/4) + nn
//       <= 16c(n/4)的平方lg(n/4) + nn
//        = cnnlgn +  (1-2c)nn
//       <= cnnlgn  (when c >= 1/2)
// d T(n) = 7T(n/3) + nn
//   a=7,b=3,n的logb(a)次方 < f(n)=nn
//   T(n) = theta(nn)
//   Prove: T(n) <= cnn
//   T(n) = 7(n/3) + nn
//       <= c7(n/3)的平方 + nn
//        = (7c/9 + 1)nn
// e T(n) = 7T(n/2) + nn
//   a=7,b=2,n的logb(a)次方 > f(n)=nn
//   T(n) = theta(n的log2(7)次方)
//   Prove: T(n) <= cn的log2(7)次方 - dnn
//   T(n) = 7T(n/2) + nn
//       <= 7c(n/2)的log2(7)次方 -d(n/2)的平方 + nn
//        = cn的log2(7)次方 + (1 - d/4)nn
//       <= cn的log2(7)次方 (when d >= 4)
// f T(n) = 2T(n/4) + 根号n
//   a=2,b=4,n的logb(a)次方=根号n = f(n)
//   T(n) = theta((根号n)lgn)
//   Prove: T(n) <= c(根号n)lgn
//   T(n) = 2T(n/4) + 根号n
//       <= 2c(根号n/4)lg(n/4) + 根号n
//        = c(根号n)lgn + (1 - 2c)(根号n)
//       <= c(根号n)lgn (when c >= 1/2)
// g T(n) = T(n-2) + nn
//   不适用主方法，采用递归树法。
//   T(n) = nn + (n-2)的平方 + (n-4)的平方 +...+ T(2)
//        = 求和(0 to n/2 - 1)(n - 2i)的平方 + T(2)
//        = theta(nnn)

// 2 参数传递的代价
//  1 数组通过指针传递，时间=theta(1)
//  2 数组通过元素复制来传递，时间=theta(N) (N为数组规模)
//  3 传递数组时，只复制过程可能访问的子区域，时间=theta(q-p+1) (子区间长度)
// a 采用递归二分查找法，求三种情况下最坏运行时间的递归式，并给出解的上界。
//   1 T(n) = T(n/2) + c =theta(lgn)
//   2 T(n) = T(n/2) + cN = T(n/4) + 2cN =...= 求和(0 to lgn-1)(2的i次方cN) = cNlgn =theta(nlgn)
//   3 T(n) = T(n/2) + cn = theta(n)
// b 采用归并排序
//   1 T(n) = 2T(n/2) + cn = theta(nlgn)
//   2 T(n) = 2T(n/2) + cn + 2N 
//          = 求和(0 to lgn-1)(cn + 2的i次方N) 
//          = cnlgn + N((2的lgn次方-1)/(2-1))
//          = cnlgn + nN - N
//          = theta(nn)
//   3 T(n) = 2T(n/2) + cn + 2n/2
//          = 2T(n/2) + (c+1)n
//          = theta(nlgn)

// 3 给出每个递归式的渐近上下界，并验证。假定对足够小的n，T(n)是常数。
//  1 T(n) = 4T(n/3) + nlgn
//    a=4,b=3,n的logb(a)次方=n的log3(4)次方=n(n的log3(4/3)次方) > nn > f(n)=nlgn
//    T(n) = theta(n的log3(4)次方)
//  2 T(n) = 3T(n/3) + n/lgn
//    a=3,b=3,n的logb(a)次方=n   f(n)=n/lgn
//    when n>=2  n的logb(a)次方 >= f(n)   so T(n) = theta(n)
//    or 积分求和的近似
//    T(n) = 3T(n/3) + n/lgn = ntheta(1) + 求和(0 to log3(n-1)) (n/(lg n-1))
//         = theta(n) + 求和(1 + lgn - log3(n)) (1/i)
//         = theta(nlglgn)
//  3 T(n) = 4T(n/2) + nn根号n
//    a=4,b=2,n的logb(a)次方=nn < f(n)
//    T(n) = theta(nn根号n)
//  4 T(n) = 3T(n/3 - 2) + n/2
//    n足够大时，忽略-2. a=3,b=3,n的logb(a)次方n = f(n)
//    T(n) = theta(nlgn)
//  5 T(n) = 2T(n/2) + n/lgn
//    积分求和近似
//    T(n) = 2T(n/2) + n/lgn
//         = theta(n) + 求和(0 to lg n-1) (n/(lgn - i))
//         = theta(nlglgn)
//  6 T(n) = T(n/2) + T(n/4) + T(n/8) + n
//    类4.4-6，从log8(n)开始不完全，每层代价为cn，层高为lgn
//    T(n) >= O(nlgn)
//  7 T(n) = T(n-1) + 1/n
//    积分求和近似
//    T(n) = T(n-1) + 1/n
//         = 1/n + 1/(n-1) + T(n-2)
//         = 求和(0 to n-1) (1/(n-i)) + theta(1)
//         = theta(lgn)
//  8 T(n) = T(n-1) + lgn
//    递归树
//    T(n) = 求和(0 to n-1)(lg n-i)
//         = 求和(1 to n) (lgi) + theta(1)
//         = theta(lg(n!))
//        <= theta(nlgn)
//  9 T(n) = T(n-2) + 1/lgn
//    积分求和的近似
//    T(n) = 1/lgn + 1/lg(n-2) +...+ theta(1)
//         = 求和(0 to n/2 - 1)(1/lg(n-2i))
//         = 求和(2 to n)(1/lgi)
//         = 求和(1 to lgn)(1/i)
//         = theta(lglgn)
//  10 T(n) = 根号nT(根号n) + n
//     换元法 + 主定理
//     令S(n) = T(n)/n,则S(n) = S(根号n) + 1
//     考虑n=2的m次方时，有S(2的m次方) = S(2的m/2次方) + 1
//     令P(m) = S(2的m次方),则P(m) = P(m/2) + 1
//     a=1,b=2,n的logb(a)次方=1 = f(n)
//     P(m) = theta(lgm)
//     T(n) = nS(n) = nP(m) = theta(nlgm) = theta(nlglgn)

// 4 Fibonacci numbers (Fi = Fi-1 + Fi-2)
//   讨论递归式定义的斐波那契数的性质。使用生成函数技术求解斐波那契递归式。
//   生成函数(形式幂级数F) F(z) = 求和(0 to 无穷)(Fi(z的i次方))
//   a Prove:F(z) = z + zF(z) + zzF(z)
//     F(z) = z + z求和(0 to 无穷)(Fi(z的i次方)) + zz求和(0 to 无穷)(Fi(z的i次方))
//          = z + 求和(1 to 无穷)(Fi-1(z的i次方)) + 求和(2 to 无穷)(Fi-2(z的i次方))
//          = z + 求和(2 to 无穷)((Fi-1 + Fi-2)(z的i次方))
//          = z + 求和(2 to 无穷)(Fi(z的i次方))
//          = F(z)
//   b Prove: F(z) = z/(1-z-zz) = z/(1-fz)(1-f'z) = 1/根号5(1/(1-fz) - 1/(1-f'z))
//     f = (1+根号5)/2  f' = (1 - 根号5)/2
//     From a: F(z) = z/(1-z-zz)
//   c Prove: F(z) = 求和(0 to 无穷)(1/根号5(f的i次方 - f'的i次方)(z的i次方))
//     由几何级数性质1/(1-x) = 求和(0 to 无穷)(x的k次方) (when -1<x<1)
//     F(z) = 1/根号5(1/(1-fz) - 1/(1-f'z))
//          = 1/根号5(求和(0 to 无穷)((f的i次方)(z的i次方)) - 求和(0 to 无穷)((f'的i次方)(z的i次方)))
//          = 求和(0 to 无穷)(1/根号5(f的i次方 - f'的i次方)(z的i次方))
//   d Prove: 对i>0, Fi = f的i次方/根号5，结果舍入到最接近的整数。
//     Fi = f的i次方/根号5 - f'的i次方/根号5
//     Fi = {0，1，2，3，5，8，13，......}
//     当i>0 , -1<f'<1时， -0.5<f'的i次方/根号5<0.5
//     所以，对一个整数，加减一个小于0.5的数，对所得结果舍入到最近整数即可。
