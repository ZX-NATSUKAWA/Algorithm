// 算法在计算中的作用
// 1.1 算法Algorithm
//   任何良定义的计算过程，将某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法在这个过程中就是一系列计算步骤的序列。
//   对一个问题的阐述，表明期望的输入/输出关系，算法描述了一个特定过程来实现这种关系。
//   正确的算法：输入实例算法以正确的输出停机。
//   不正确的算法在错误率可控时可能是可用的。
//   算法问题共有的特征：1 存在许多候选解，找尽可能的最优解。  2 存在实际应用。

// 1.1.1  以排序问题举例：
//     输入：n个数的序列
//     输出：输入序列的一个排列，满足一定关系
//     给定输入序列，称为排序问题的一个实例。   问题实例由计算该问题必须的（满足问题中的各种约束）输入组成。
//   排序问题在应用中选择算法的影响因素：将被排序的项数、这些项已被排序的程度、项值的限制、计算机体系结构、存储设备种类。

// 1.1.2 数据结构：一种存储和组织数据的方式，旨在便于访问和修改。

// 1.1.3 技术：无法用已有算法来解决问题时，能够自行设计算法、证明正确性、计算其效率。

// 1.1.4 难题
//   对于有效算法，用产生结果需要的时间来衡量其效率。
//   对于未知有效算法的问题，称之为难题。
//       如：NP完全问题（Non-deterministic Polynomial Problem/多项式复杂程度的非确定性问题）
//       1 现状：目前仍未找到对NP完全问题的有效算法
//       2 其性质：如果任一Np完全问题存在有效算法，那么所有NP完全问题都存在有效算法。
//       3 意义：有几个NP完全问题类似存在有效算法的问题，但不完全等同。可以用对问题陈述的小变动来极大改变已有算法的效率。
//       所以，如果一个问题NP完全，可以有有效算法去解决，但不一定是最佳算法，这种算法被称为“近似算法”。

// 1.1.5 并行性
//   单线程：一个计算核心处理问题，一步一步顺序往下运行。（随着功率提高，存在物理限制，不能无限提高性能）
//   多线程（并行）：用多个计算核心，分解问题，每个核心负责部分运算。（可以通过增加核心量来提高计算效率）
//   因此为了从多核计算机获取最佳性能，设计算法时要考虑并行性。


// 1.2.2 算法与其他技术
//   其他对系统性能重要的技术：
//     先进的计算机体系结构与制造技术
//     易于使用、直观的图形用户界面
//     面向对象的系统
//     集成的万维网技术
//     有线与无线的快速组网



// 算法基础
// 介绍一个贯彻始终的框架，后续的算法设计与分析都基于这个框架，就像骨头上长出肌肉、血管乃至皮肤。
// 以排序问题的插入排序算法为例，引入伪代码说明算法执行步骤、功能，分析其运行时间。
// 引入分治法开发归并排序算法，分析其运行时间。

// 2.1 插入排序
//   选出一个数，从左向右（其实就是按一个顺序）依次比较，然后放入合适的位置。
// 例
//int main()
//{
//	int arr[5];
//	int i, j, t;
//	printf("输入5个元素：");
//	for (i = 0; i < 5; i++)
//		scanf_s("%d", &arr[i]);
//	for (j = 1; j < 5; j++)       // 指出正在被插入的当前数。
//	{
//		t = arr[j];
//		i = j - 1;
//		while (i >= 0 && arr[i] > t) //循环不变式
//		{
//			arr[i + 1] = arr[i];
//			i = i - 1;
//		}
//		arr[i + 1] = t;
//	}
//	for (i = 0; i < 5; i++)
//		printf("%d ", arr[i]);
//	return 0;
//}
// 循环不变式三条性质
//     1 初始化：循环第一次迭代之前为真。（循环起码能运行一次）
//     2 保持：如果循环某次迭代为真，那下次迭代之前仍为真。（保证未满足终止条件时，循环能正常继续下去）
//     3 终止：循环终止时，证明算法是正确的。（类似for，while循环的终止条件）
// 伪代码中的一些约定：
//       1 缩进代表块结构。
//       2 退出循环后，计数器保持当前值。
//       3 符号//后内容表示注释。
//       4 多重赋值表达式，r如i=j=e,将e的值赋给i和j。
//       5 若无特殊说明，变量均为局部变量。
//       6 数组元素通过数组名[下标]来访问。
//       7 复合数据通常被组织成对象，对象又由属性组成。对象名.属性名，可以逐级向下访问。
//         把表示一个数组或对象的变量看做是其指针。y=x后，xy指向相同的对象。
//         属性记号还可串联。如f指向g，记作f.g，又x.f.g。如果y=x.f ,根据上一条有x.f.g = y.g
//         空指针可以记作NIL
//       8 按值把参数传递给过程，当对象被传递时，指向表示对象数据的指针被复制而其属性没有。

// 2.2 分析算法
//   分析算法的结果意味着预测算法需要的资源。通过分析求解某个问题的候选算法，从中选出最有效的。
//   分析前要使用一个实现技术的模型（一台假想电脑）。本书中假定为一种通用的单处理器计算模型（随机访问机）
//   RAM模型包含真实计算机的常见指令：算术指令、数据移动指令、控制指令。每条指令所需时间均为常量。
//          数据类型：整数型、浮点型。 对每个数据字节假定一个范围以符合使用需要、实际情况。
//          分析过程需要使用到的数学工具可能包括：组合学、概率论、代数技巧，识别一个公式中最具意义的项。
//          通常只选一种机器模型来分析某个给定的算法。

// 2.2.1 插入排序算法的分析（asymptotic analysis渐进分析）
//   2.2.1.1 插入排序过程需要的时间依赖输入规模。 一般来说，算法需要时间随输入规模同步增长，所以将一个程序的运行时间描述为输入规模的函数。
//       输入规模：依赖研究的问题。对不同问题，输入规模的量度不同（单位不同）。
//       运行时间：执行的基本操作数或步数
//   分析过程中，由繁到简地改进运行时间表达式，并用简单记号表示语句代价Ci（忽略具体的实际代价），更关注增长率。
//               假定注释是不可执行语句，不需要运行时间。
//   2.2.1.2 现分析伪代码如下：
//   for j=2 to A.length           c1  n
//       key = A[j]                c2  n-1
//       // insert A[j] into sort   0  n-1
//       i=j-1                     c4  n-1
//       while i>0 and A[i]>key    c5  tj(for j=2 to n求和)
//             A[i+1] = A[i]       c6  tj-1(for j=2 to n求和)
//             i = i -1            c7  tj-1(for j=2 to n求和)
//       A[i+1] = key              c8  n-1
//   算法运行时间=代价 x 次数 的总和
//   T(n) = c1n + c2(n-1) + c4(n-1) + c5(求和tj) + c6(求和tj-1) + c7(求和tj-1) + c8(n-1)
//       最佳情况 T(n) = (c1+c2+c4+c5+c8)n - (c2+c4+c5+c8) = an - b
//       最坏情况 T(n) = (c5/2+c6/2+c7/2)nn + (c1+c2+c4+c5/2-c6/2-c7/2+c8)n - (c2+c4+c5+c8) = ann + bn + c
//   注：通常运行时间对给定输入是固定的，但是也有一些随机化算法（对固定输入，其行为可能变化导致运行时间不定）

// 2.2.2 最坏情况和平均情况的分析
//     往往只考虑求最坏情况的运行时间，即对于输入规模n，算法最长运行时间。
//         最坏情况运行时间给出任何输入的运行时间上界，能确保该算法绝不会超出这个运行时间。
//         对于某些算法，最坏情况经常出现。
//         平均情况往往和最坏情况一样差。
//         随机化算法中，假定给定规模的所有输入具有相同的可能性，以允许进行概率分析并产生某个期望的运行时间。
// 注：期望是一种均值，是试验中每次可能结果的概率 x 结果的总和，用于反应随机变量平均取值大小。

// 2.2.3 增长量级
//   使用简化抽象以化简分析。
//       Ci表示代价以忽略实际代价。常量a,b,c忽略Ci进一步简化
//       关注增长率，只考虑最重要的项，如最高次项。
//       当忽略低价项及最重要项的常系数时，使用asymptotic notation（theta），记为o(最重要项因子)


// 2.3 设计算法
//   插入排序使用了增量方法（排序好子列后，将后面的元素插入子列）
//   分治法，其最坏运行时间比插入排序要少得多。
// 2.3.1 分治法
//   在算法结构上是递归的：为了解决一个给定问题，一次或多次递归调用自身来解决相关的子问题。
//   思想：原问题分解为规模较小且类似的子问题，递归求解子问题，合并子问题的解来求出原问题的解。
//   步骤：分解，解决，合并。  当待排序列长度为1时，递归开始回升。
//   2.3.1.1 
//     MERGE(A,p,q,r) 合并函数，用于合并子数列A[p...q]和A[q+1...r],结果为A[p...r]
//     过程MERGE需要o(n)的时间 n=r-p+1（待合并元素总数），每次比较两个数组的当前元素，较小的放到输出数组中，放一次比一次，直到n个元素全放入输出数组。
//     如果当一个数组已经全部放入输出数组，则另一个数组剩余元素没有必要继续比较，可直接顺次放入输出数组。所以在数组底部放特殊值，当比较时出现该值可直接跳过比较。
//     伪代码如下：
//     MERGE(A,p,q,r)
//       n1=q-p+1
//       n2=r-q
//       //let L[1...n1+1]  and R[1...n2+1] be new arrays
//       for i=1 to n1
//           L[i] = A[p+i-1]
//       for j=1 to n2
//           R[j] = A[q+j]
//       L[n1+1] = infinitas
//       R[n2+1] = infinitas
//       i = 1
//       j = 1
//       for k=p to r
//           if L[i] <= R[j]
//              A[k] = L[i]
//              i = i + 1
//           else A[k] = R[j]
//                j = j + 1
//     MERGE-SORT (A,p,r)
//       if p<r
//          q=[(p+r)/2] (取整)
//           MERGE-SORT (A,q,r)
//           MERGE-SORT (A,q+1,r)
//           MERGE (A,p,q,r)
//     C语言封装成函数如下： //(有问题)
//void Merge(char arr[],int p,int q,int r)
//{
//	int i, j, k, n1, n2;
//	n1 = q - p;
//	n2 = r - q;
//	char L[5], R[5];
//	for (i = 0; i < n1; i++)
//		L[i] = arr[p + i];
//	for (j = 0; j < n2; j++)
//		R[j] = arr[q + j];
//	L[i + 1] = 'N';
//	R[i + 1] = 'N';
//	i = 0;
//	j = 0;
//	for (k = p; k < r; k++)
//	{
//		if (L[i] <= R[j])
//		{
//			arr[k] = L[i];
//			i++;
//		}
//		else
//		{
//			arr[k] = R[j];
//			j++;
//		}
//	}
//}
//void Merge_sort(char arr[], int p, int r)
//{
//	int q = 0;
//	if (p < r)
//	{
//		q = (p + r) / 2;
//		Merge_sort(arr, p, q);      // 左列排序
//		Merge_sort(arr, q + 1, r);  // 右列排序
//		Merge(arr, p, q, r);        // 合并左右列
//	}
//}
//int main()
//{
//	int i;
//	char arr[6] = { '2','6','4','5','9','1' };
//	int p = 0;
//	int r = sizeof(arr);
//	/*printf("%d", r);*/
//	Merge_sort(arr, p, r);
//	for (i = 0; i < r; i++)
//		printf("%c ", arr[i]);
//	return 0;
//}

// test
// 2.3-2 重写MERGE，不用哨兵。
//   MERGE(A,p,q,r)
//   n1=q-p+1
//   n2=r-q
//   for i=1 to n1
//       L[i]=A[p+i-1]
//   for j=1 t0 n2
//       R[j]=A[q+j]
//   i=1
//   j=1
//   while i<=q and j<=r
//        for k=p to r
//          if L[i]<=R[j]
//             A[k]=L[i]
//             i=i+1
//          else A[k]=R[j]
//               j=j+1
//   while k<=r  
//        if i == q+1
//           A[k]=R[j]
//           k=k+1
//           j=j+1
//         else
//           A[k]=L[i]
//           k=k+1
//           j=j+1

// 2.3.4 插入排序：为排序A[1...n],递归排序A[1...n-1],然后插入A[n]，求最坏运行时间递归式
//   1 分解：当数组只剩一个元素时，耗时为常量，记作o(1)
//   2 解决：递归求解n-1个元素，需要时间T(n-1)
//   3 合并：一个具有n-1个元素的数组，插入第n个元素需要时间cn
//   递归式 T(n) = o(1)         n=1
//               = T(n-1) + cn  n>1

// 2.3.5 二分法查找最坏运行时间
//   BINARY_SEARCH(A,x)
//     low=1
//     high=A.length
//     while low<=high
//       mid=(low+high)/2
//       if A[mid] == x
//          return mid
//       elseif A[mid]<x
//          low=mid+1
//       else
//          high=mid-1
//   T(n+1)=T(n/2)+c  最坏运行时间o(lgn)

// 2.3.7 给定n个整数的集合S和另一个整数x，确定S中是否存在两个和刚好为x的元素，其运行时间为o(nlgn)
//   SUM_FIND(S,x)
//     MERGE_SORT(S,1,S.length) // 先将S从小到大归并排序 o(nlgn)
//     for i=1 to S.length      // 再二分法查找是否存在两个数和为x。 需要时间： n x o(lgn) = o(nlgn)
//         if BINARY_SEARCH(S,x-S[i]) != nil // 找到了
//            return ture
//     return false                          // 没找到
//     总运行时间为o(nlgn)

// 2.1 在归并排序中对小数组采用插入排序
//   1 插入排序：排序n/k个长度为k的子表。排序一个需要T(k)=akk+bk+c,n/k个T=n/k(akk+bk+c)=ank+bn+cn/k=o(nk)
//   2 递归式 T(a)= 0          a=1
//              = T(a/2)+ak  a=2
//     归纳得 T(a)=aklga
//     T(n/k)=nlg(n/k)   so  o(nlg(n/k))
//   3 o(nk+nlg(n/k))<=o(nlgn)
//     so k<=lg(n/k)   k max 满足k2k次幂<n
//   4 当递归的子问题耗时大于直接插入排序时对应的k即为所求

// 2.2 冒泡排序正确性
//   1 还需证明A'中的所有元素就是A中各个元素
//   2 证明j循环的循环不变式
//     初始化：第一轮迭代开始前，只有j=A[length]一个元素，显然已排序，所以第一轮迭代之前已成立
//     保持：  迭代之前，假设A[j]...A[length]是已排序的，待排序元素A[j-1]依次与A[j]...A[length]比较，
//             如果A[j-1] > A[j],则交换位置，此时整个数列已排好序。
//             即j成立情况下，j-1也成立，证明其迭代过程中保持成立。
//     终止：  当i=A.length-1时，j=A.length,A'[1...n]个元素都已排好序。
//   3 证明i,j循环不变式
//     初始化：第一次循环开始时，A[1...i-1]为空数组，循环不变式成立。
//     保持：  A[1...i-1]满足循环不变式条件，j循环保证A[i]为A[i...n]中最小的元素。
//             迭代之前，A[1...i-1]内是已升序排序的数组，且A[i]大于A[1...i-1]中每个元素
//             即A[1...i-1]成立条件下，A[1...i]也成立,证明其迭代过程中保持成立。
//     终止：  i=n,A[1...n-1]满足循环不变式，由于A[1...n-1]由数组中最小的数组成，则A[n]必大于[1...n-1]所有数，则A[1...n]已排好序。
//   4 冒泡排序最坏运行时间o(nn),且无论是否已排好序。每次都执行判断，循环总次数不变,实际运行时间恒等于o(nn).
//     插入排序最坏运行时间o(nn),一旦找到插入位置循环结束，实际运行时间<=o(nn)
//     总体而言，插入排序性能更佳

// 2.3 霍纳Horner规则正确性
//   给定系数ai(i=1...n)和x的值
//   y=0
//   for i=n downto 0
//       y=ai + xy
//   实现了求值多项式 P(x) = 求和ak(x的k次幂) = a0 + x(a2+...+x(an-1+xan)...))
//   1 o(n)
//   2 嵌套循环城际结果累加 o(nn),比霍纳规则慢
//   3 证明循环不变式
//     初始化：i=n,y=0,循环不变式成立。
//     保持：  迭代开始时，y=求和(k=0,n-i-1)a(k+i+1)(x的k次幂)
//             循环后y = ai+x求和(k=0,n-i-1)a(k+i+1) = ai(x的0次幂)+求和(k=1,n-i)a(k+i)(x的k次幂)
//             y = a(k+i)(x的0次幂) + 求和(k=1,n-i)a(k+i)(x的k次幂) = 求和(k=0,n-i)a(k+i)(x的k次幂)迭代过程中保持成立。
//     终止：i=-1 ,y=求和(k=0,n)ak(x的k次幂)

// 2.4 逆序对 数组元素大小顺序与下标顺序相反
//   1 2，3，8，6，1的五个逆序对 ： (3,4),(3,5),(4,5),(1,5),(2,5)
//   2 {n...2,1}具有最多逆序对，有(n-1+1)(n-1)/2
//   3 INSERTION_SORT(A):
//        c=0
//        for j=2 to A.length
//            key=A[j]
//            i=j-1
//            while i>0 and A[i]>key
//                  A[i+1]=A[i]
//                  i=i-1
//                  c=c+1
//             A[i-1]=key
//    Prove：
//          1 初始化：第一次循环开始前，c=0，A[1]只有一个元素，不存在逆序对，不变式成立。
//          2 保持：  c为当前A[1...j-1]的逆序对个数。
//                    本次循环时，在A[1...j-1]中找比A[j]大的元素，直至退出子循环。
//                    循环结束A[1...j-1]都比A[j]小，A[j+1...n]都比A[j]大。此时c为A[j]与A[1...j-1]的逆序对个数，不变成成立。
//          3 终止：   j=A.length+1，c为A[1...n]的逆序对个数。
//    4 
//int Merge(int arr[], int p, int q, int r)
//{
//	int c = 0, k = 0, i, j;
//	int n1 = q - p + 1;
//	int n2 = r - q;
//	int* L = (int*)malloc((n1+1) * sizeof(int));
//	int* R = (int*)malloc((n2+1) * sizeof(int));
//	for (i = 0; i < n1; i++)
//		*(L + i) = arr[p + i];
//	for (j = 0; j < n2; j++)
//		*(R + j) = arr[q + 1 + j];
//	*(L + i) = 100;
//	*(R + j) = 100;
//	i = 0;
//	j = 0;
//	for (k = p; k <= r; k++)
//	{
//		if (*(L + i) <= *(R + j))
//		{
//			arr[k] = *(L + i);
//			i++;
//		}
//		else
//		{
//			arr[k] = *(R + j);
//			j++;
//			c++;
//		}
//	}
//	//while( i<=q && j<=r)
//	//{
//	//	for (k = p; k <= r; k++)
//	//	{
//	//		if (*(L + i) <= *(R + j))
//	//		{
//	//			arr[k] = *(L + i);
//	//			i++;
//	//		}
//	//		else
//	//		{
//	//			arr[k] = *(R + j);
//	//			j++;
//	//			c++;
//	//		}
//	//	}
//	//}
//	//while (k <= r)
//	//{
//	//	if (i == q + 1)
//	//	{
//	//		arr[k] = *(R + j);
//	//		k++;
//	//		j++;
//	//	}	
//	//	else
//	//	{
//	//		arr[k] = *(L + i);
//	//		k++;
//	//		j++;
//	//	}
//	//}
//	free(L);
//	free(R);
//	return c;
//}
//int Merge_sortC(int arr[], int p, int r)
//{
//	int c = 0;
//	if (p < r)
//	{
//		int q = (p + r) / 2;
//		return Merge_sortC(arr, p, q) + Merge_sortC(arr, q + 1, r) + Merge(arr, p, q, r);
//	}
//	else
//		return 0;
//}

//int Merge_sort(int a[], int p, int q, int r)
//{
//	int t[5];
//	int c = 0;
//	int i = p;
//	int j = q + 1;
//	for (int k = p; k <= r; k++)
//	{
//		if ((j > r) || (i <= q) && (a[i] <= a[j]))
//			t[k] = a[i++];
//		else
//		{
//			t[k] = a[j++];
//			c += q - i + 1;
//		}
//	}
//	for (i = p; i <= r; i++)
//		a[i] = t[i];
//	return c;
//}
//int Merge_sortC(int a[], int p, int r)
//{
//	if (p < r)
//	{
//		int q = p + (r - p) / 2;
//		return Merge_sortC(a, p, q) + Merge_sortC(a, q + 1, r) + Merge_sort(a, p, q, r);
//	}
//	else
//		return 0;
//}
//int main()
//{
//	int arr[5] = { 2,3,8,6,1 };
//	int c = Merge_sortC(arr, 0, 4);
//	printf("%d", c);
//	return 0;
//}



// 函数增长
//   虽然有时能确定一个算法的精确运行时间，但是通常不值得计算获得多余精度。
//   当输入规模足够大时，只与运行时间的增长量级有关时，研究算法的渐进效率。

// 3.1 渐进记号
//   用来描述算法渐进运行时间的记号根据定义域为自然数集N的函数来定义。 （对整数输入规模）
//   但采用渐进记号更为方便。（目的还是为了简化）

// 3.1.1 渐进记号、函数与运行时间
//   如插入排序，其最坏运行时间可写为函数T(n)=ann+bn+c,使用渐进记号o(nn)来描述它。
//   除时间函数外，渐进记号还可以描述算法的其他方面，如：空间数量，甚至是与算法无关的函数。
//   使用渐进记号来描述算法运行时间，不光是最坏运行时间，更希望是对所有输入的，因此有完全适合任何输入的运行时间的渐进记号。
//   3.1.1.1 theta记号
//   对于一个给定函数g(n),用theta(g(n))来表述以下函数的集合：
//   theta(g(n)) = {f(n):存在正常量c1,c2和n0，使得对所有n >= n0,有0 <= c1g(n) <= f(n) <= c2g(n)}
//      解读：若存在正常数c1和c2，使得对于足够大的n，函数f(n)能夹入c1g(n)和c2g(n)之间，则f(n)属于集合o(g(n))。
//            因为theta(g(n))是一个集合，，所以f(n)是它的成员，可以记为f(n)属于theta(g(n))，替代记为f(n)=tehta(g(n))
//            类似于夹逼准则，对所以n>=n0,f(n)在常量因子内等于g(n),称g(n)是f(n)的一个渐进紧确界。
//            定义要求，每个成员f(n)均渐进非负（c>0 nn>0,f夹在两者之间必非负）
//   简单记忆：只保留最高次项。 准确定义：如上。
//   Prove:  c1nn <=   ann+bn+c    <= c2nn    // 必有a>0
//           c1   <=  a+b/n+c/nn   <= c2      // 对不同n，可确定不同c1、c2,反之亦可。
//           c1/a <=  1+b/an+c/ann <= c2/a    // 进一步，最高次项的系数也可以忽略。
//          一般性的，对任意d阶多项式p(n),有p(n)=o（n的d次方）
//   3.1.1.2 O记号
//   相对theta记号给出一个函数的上界和下界，当只有一个渐进上界时，使用O记号。
//   对于一个给定函数g(n),用O(g(n))来表述以下函数的集合：
//   O(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0,有0 <= f(n)<= cg(n)}
//      解读：给出函数的上界，即对n0及其右边的所有n值，f(n) <= cg(n)
//            记f(n)=O(g(n)). 注意f(n)=o(g(n))中包含f(n)=O(g(n))。
//            当使用f(n)=O(g(n))时，仅仅要求g(n)的某个常数倍是f(n)的上界，但这个上界并不一定紧确。
//            使用O记号描述上界，可以仅通过算法的总体结构来描述算法运行时间,但由于输入变化，其最坏运行时间为O(nn)，但其他情况下不是。
//   3.1.1.3 Omiga记号
//   Omiga记号提供了函数下界。
//   对于一个给定函数g(n),用Omiga(g(n))来表述以下函数的集合：
//   Omiga(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0，有0 <= cg(n) <= f(n)}
//      解读：给出函数的上界，即对n0及其右边的所有n值，cg(n) <= f(n)

// 3.1.2 定理3.1
//   对于任意两个函数f(n)和g(n),有f(n)=o(g(n))。当且仅当f(n)=O(g(n))且f(n)=Omiga(g(n)).
//   对于ann+bn+c=0(nn)，实际应通过定理3.1从渐进确界获取渐进上下界，用渐进上界和下界证明渐进确界。
//   算法的最佳情况运行时间为Omiga，最坏运行情况时间为O，所以算法运行时间就在两者确定的渐进确界之间，需要时间为o

// 3.1.3 等式和不等式中的渐进记号
//   渐进记号可以用于数学公式中。
//   当渐进记号独立于等式或不等式一侧时，已经明确等号所指的集合关系。但渐进记号出现于在某个公式中时，将其解释为匿名函数。
//      如：2nn+3n+1=2nn+theta(n) 意为 2nn+3n+1=2nn+f(n)  f(n)为theta(n)中的某个函数。称f(n)为匿名函数。
//          总之利用渐进记号，消除等式中无关杂项（多为低阶项）。
//          一个表达式中匿名函数的数目可以理解为等于渐进记号出现的次数。
//   当渐进记号出现在等式一侧时，如： 2nn+theta(n)=theta(nn)
//         无论怎样选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。
//         等式右边是等式左边的进一步简化版。
//   3.1.3.1 o记号
//     O记号提供的渐进上界可能不是紧确的。如：2nn=O(nn)是紧确的 2n=O(n)却不是。
//     因此采用o记号来表示一个非渐进紧确的上界。 对于一个给定函数g(n),用o(g(n))来表述以下函数的集合：
//     o(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0,有0 <= f(n)< cg(n)}
//     极限n趋于无穷，f(n)/g(n)=0,可以作为o记号的定义。
//   3.1.3.2 w记号
//     w记号于Omiga记号的关系类似o记号与O记号的关系。 用w记号表示一个非渐进紧确的下界。
//     对于一个给定函数g(n),用w(g(n))来表述以下函数的集合：
//     w(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0，有0 <= cg(n) < f(n)}
//     极限n趋于无穷，f(n)/g(n)=无穷,可以作为o记号的定义。
//     也可以利用o记号定义： f(n) belong w(g(n))     only when     g(n) belong o(f(n))
//   3.1.3.3 应用
//     实数的许多关系性质也适用于渐进比较。 假定f(n)、g(n)渐进为正。
//     1 传递性
//       f(n)=theta(g(n))  and   g(n)=theta(h(n))    so   f(n)=theta(h(n))
//       f(n)=O(g(n))      and   g(n)=O(h(n))        so   f(n)=O(h(n))
//       f(n)=Omiga(g(n))  and   g(n)=Omiga(h(n))    so   f(n)=Omiga(h(n))
//       f(n)=o(g(n))      and   g(n)=o(h(n))        so   f(n)=o(h(n))
//       f(n)=w(g(n))      and   g(n)=w(h(n))        so   f(n)=w(h(n))
//     2 自反性
//       f(n) = theta(f(n))
//       f(n) = O(f(n))
//       f(n) = Omiga(f(n))
//     3 对称性
//       f(n) = theta(g(n))  only when  g(n) = theta(f(n))
//     4 转置对称性
//       f(n) = O(g(n))      only when  g(n) = Omiga(f(n))
//       f(n) = o(g(n))      only when  g(n) = w(f(n))
//     5 类比
//       O      a<=b  ;   o  a<b
//       Omiga  a>=b  ;   w  a>b
//       theta  a=b
//     6 三分性
//       对任意两个实数a，b，必存在三种关系中的某一种:a<b,a=b,a>b
//       但对于函数并不一定，即不是所有函数都可以渐进比较。


// test
// 3.1.1 
//   c1f(n) <= f(n) <= c2f(n)
//   c3g(n) <= g(n) <= c4g(n)
//   不妨设f(n) >= g(n)，则max(f(n),g(n))=f(n)
//   所以存在c5,c6，满足c5（f(n)+g(n)) <= f(n)=max(f(n),g(n)) <= c6(f(n)+g(n))
//   即证max(f(n),g(n))  =  theta(f(n)+g(n))

// 3.1.2
//   将（n+a）的b次方，多项式展开得，最高次项为n的b次方.
//   所以（n+a）的b次方 = theta(n的b次方)

// 3.1.3
//   O记号代表算法运行时间上限，与表述“运行时间至少”相矛盾。

// 3.1.4
//   2的(n+1)次方 = 2x2的n次方 = O(2的n次方) 成立 
//   2的2n次方    = 2的n次方 x 2的n次方 不等于 cx2的n次方  不成立

// 3.1.5 
//   因为 f(n) = theta(g(n))
//   所以 f(n)满足 c1g(n) <= f(n) <= c2g(n)
//   即同时满足  c1g(n) <= f(n)      ,   f(n) <= c2g(n)
//   即同时满足  f(n) = Omiga(g(n))  ,   f(n) = O(g(n))
//   所以 f(n) = theta(g(n)) 与 f(n) = Omiga(g(n))，f(n) = O(g(n))同时成立 两者等价。

// 3.1.6
//   类3.1.5证明。 Omiga(g(n))代表算法下界（最好情况运行时间），O(g(n))代表算法上界（最坏情况运行时间）

// 3.1.7
//   反证法  设存在f(n) = o(g(n))∩w(g(n))
//   则f(n)满足 f(n)<c1g(n)  且 f(n)>c2g(n)>=0
//   因为c1,c2是任意常数，令c1=c2，则 cg(n)<f(n)<cg(n)
//   不存在f(n)满足上不等式，矛盾，故o(g(n))∩w(g(n))为空集。

// 3.1.8
//   记号有两个参数的情况（n,m）
//   O(g(n,m)) = {f(n,m):存在正常量c、n0和m0,使得对所有n>=n0或m>=m0,有0 <= f(n,m) <= cg(n,m)}
//   Omiga(g(n,m)) = {f(n,m):存在正常量c、n0和m0,使得对所有n>=n0或m>=m0,有0 <= cg(n,m) <= f(n,m)}
//   theta(g(n,m)) = {f(n,m):存在正常量c1、c2、n0和m0,使得对所有n>=n0或m>=m0,有0 <= c1g(n,m) <= f(n,m) <= c2g(n,m)}
